# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `little-plugger` gem.
# Please instead update this file by running `bin/tapioca gem little-plugger`.

# source://little-plugger//lib/little-plugger.rb#278
module Kernel
  # call-seq:
  #    LittlePlugger( opts = {} )
  #
  # This method allows the user to override some of LittlePlugger's default
  # settings when mixed into a module or class.
  #
  # See the "Customizing" section of the LittlePlugger documentation for an
  # example of how this method is used.
  #
  # ==== Options
  #
  # * :path <String>
  #    The default plugin path. Defaults to "module_name/plugins".
  #
  # * :module <Module>
  #    The module where plugins will be loaded. Defaults to
  #    ModuleName::Plugins.
  #
  # * :plugins <Array>
  #    The array of default plugins to load. Only the plugins listed in this
  #    array will be loaded by LittlePlugger.
  #
  # source://little-plugger//lib/little-plugger.rb#302
  def LittlePlugger(opts = T.unsafe(nil)); end
end

# == Synopsis
# LittlePlugger is a module that provides Gem based plugin management.
# By extending your own class or module with LittlePlugger you can easily
# manage the loading and initializing of plugins provided by other gems.
#
# == Details
# Plugins are great! They allow other developers to add functionality to
# an application but relieve the application developer of the responsibility
# for mainting some other developer's plugin code. LittlePlugger aims to
# make it dead simple to manage external plugins as gems.
#
# === Naming
# Every plugin managed by LittlePlugger will have a name represented as a
# Symbol. This name is used to register the plugin, load the plugin file,
# and manage the plugin class/module. Here are the three rules for plugin
# names:
#
# 1) all lowercase with underscores
# 2) maps to a file of the same name with an '.rb' extension
# 3) converting the name to camel case yields the plugin class / module
#
# These rules are essentially the standard ruby practice of naming files
# after the class / module the file defines.
#
# === Finding & Loading
# Plugins are found by searching through the lib folders of all installed
# gems; these gems are not necessarily loaded - just searched. If the lib
# folder has a subdirectory that matches the +plugin_path+, then all ruby
# files in the gem's +plugin_path+ are noted for later loading.
#
# A file is only loaded if the basename of the file matches one of the
# registered plugin names. If no plugins are registered, then every file in
# the +plugin_path+ is loaded.
#
# The plugin classes / modules are all expected to live in the same
# namespace for a particular application. For example, all plugins for the
# "Foo" application should reside in a "Foo::Plugins" namespace. This allows
# the plugins to be automatically initialized by LittlePlugger.
#
# === Initializing
# Optionally, plugins can provide an initialization method for running any
# setup code needed by the plugin. This initialize method should be named as
# follows: "initializer_#{plugin_name}" where the name of the plugin is
# appended to the end of the initializer method name.
#
# If this method exists, it will be called automatically when plugins are
# loaded. The order of loading of initialization is not strictly defined, so
# do not rely on another plugin being initialized for your own plugin
# successfully initialize.
#
# == Usage
# LittlePlugger is used by extending your own class or module with the
# LittlePlugger module.
#
#    module Logging
#      extend LittlePlugger
#    end
#
# This defines a +plugin_path+ and a +plugin_module+ for our Logging module.
# The +plugin_path+ is set to "logging/plugins", and therefore, the
# +plugin_modlue+ is defined as Logging::Plugins. All plugins for the
# Logging module should be found underneath this plugin module.
#
# The plugins for the Logging module are loaded and initialized by calling
# the +initialize_plugins+ method.
#
#    Logging.initialize_plugins
#
# If you only want to load the plugin files but not initialize the plugin
# classes / modules then you can call the +load_plugins+ method.
#
#    Logging.load_plugins
#
# Finally, you can get a hash of all the loaded plugins.
#
#    Logging.plugins
#
# This returns a hash keyed by the plugin names with the plugin class /
# module as the value.
#
# If you only want a certain set of plugins to be loaded, then pass the
# names to the +plugin+ method.
#
#    Logging.plugin :foo, :bar, :baz
#
# Now only three plugins for the Logging module will be loaded.
#
# === Customizing
# LittlePlugger allows the use of a custom plugin path and module. These are
# specified when extending with LilttlePlugger by passing the specific path
# and module to LittlePlugger.
#
#    class Hoe
#      extend LittlePlugger( :path => 'hoe', :module => Hoe )
#
#      plugin(
#          :clean, :debug, :deps, :flay, :flog, :package,
#          :publish, :rcov, :signing, :test
#      )
#    end
#
# All ruby files found under the "hoe" directory will be treated as
# plugins, and the plugin classes / modules should reside directly under the
# Hoe namespace.
#
# We also specify a list of plugins to be loaded. Only these plugins will be
# loaded and initialized by the LittlePlugger module. The +plugin+ method
# can be called multiple times to add more plugins.
#
# source://little-plugger//lib/little-plugger.rb#111
module LittlePlugger
  class << self
    # For a given path returns the class or module corresponding to the
    # path. This method assumes a correspondence between directory names and
    # Ruby namespaces.
    #
    #    default_plugin_module( "foo_bar/baz/plugins" )  #=> FooBar::Baz::Plugins
    #
    # This method will fail if any of the namespaces have not yet been
    # defined.
    #
    # source://little-plugger//lib/little-plugger.rb#267
    def default_plugin_module(path); end

    # For a given object returns a default plugin path. The path is
    # created by splitting the object's class name on the namespace separator
    # "::" and converting each part of the namespace into an underscored
    # string (see the +underscore+ method). The strings are then joined using
    # the File#join method to give a filesystem path. Appended to this path is
    # the 'plugins' directory.
    #
    #    default_plugin_path( FooBar::Baz )    #=> "foo_bar/baz/plugins"
    #
    # source://little-plugger//lib/little-plugger.rb#253
    def default_plugin_path(obj); end

    # Called when another object extends itself with LittlePlugger.
    #
    # source://little-plugger//lib/little-plugger.rb#226
    def extended(other); end

    # Convert the given string from camel case to snake case. Method liberally
    # stolen from ActiveSupport.
    #
    #    underscore( "FooBar" )    #=> "foo_bar"
    #
    # source://little-plugger//lib/little-plugger.rb#235
    def underscore(string); end

    # Returns the version string for the library.
    #
    # source://little-plugger//lib/little-plugger.rb#117
    def version; end
  end
end

# source://little-plugger//lib/little-plugger.rb#121
module LittlePlugger::ClassMethods
  # Add the _names_ to the list of plugins that will *not* be loaded. This
  # list prevents the plugin system from loading unwanted or unneeded
  # plugins.
  #
  # If a plugin name appears in both the 'disregard_plugin' list and the
  # 'plugin' list, the disregard list takes precedence; that is, the plugin
  # will not be loaded.
  #
  # source://little-plugger//lib/little-plugger.rb#137
  def disregard_plugin(*names); end

  # Add the _names_ to the list of plugins that will *not* be loaded. This
  # list prevents the plugin system from loading unwanted or unneeded
  # plugins.
  #
  # If a plugin name appears in both the 'disregard_plugin' list and the
  # 'plugin' list, the disregard list takes precedence; that is, the plugin
  # will not be loaded.
  #
  # source://little-plugger//lib/little-plugger.rb#137
  def disregard_plugins(*names); end

  # Iterate over the loaded plugin classes and modules and call the
  # initialize method for each plugin. The plugin's initialize method is
  # defeind as +initialize_plugin_name+, where the plugin name is unique
  # to each plugin.
  #
  # source://little-plugger//lib/little-plugger.rb#175
  def initialize_plugins; end

  # Iterate through all installed gems looking for those that have the
  # +plugin_path+ in their "lib" folder, and load all .rb files found in
  # the gem's plugin path. Each .rb file should define one class or module
  # that will be used as a plugin.
  #
  # source://little-plugger//lib/little-plugger.rb#187
  def load_plugins; end

  # Add the _names_ to the list of plugins that will be loaded.
  #
  # source://little-plugger//lib/little-plugger.rb#125
  def plugin(*names); end

  # This module or class where plugins are located.
  #
  # source://little-plugger//lib/little-plugger.rb#216
  def plugin_module; end

  # Returns the array of plugin names that will be loaded. If the array is
  # empty, then any plugin found in the +plugin_path+ will be loaded.
  #
  # source://little-plugger//lib/little-plugger.rb#147
  def plugin_names; end

  # The path to search in a gem's 'lib' folder for plugins.
  #
  # source://little-plugger//lib/little-plugger.rb#210
  def plugin_path; end

  # Loads the desired plugins and returns a hash. The hash contains all
  # the plugin classes and modules keyed by the plugin name.
  #
  # source://little-plugger//lib/little-plugger.rb#154
  def plugins; end
end

# source://little-plugger//lib/little-plugger.rb#113
LittlePlugger::VERSION = T.let(T.unsafe(nil), String)
