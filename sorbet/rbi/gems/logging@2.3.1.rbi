# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `logging` gem.
# Please instead update this file by running `bin/tapioca gem logging`.

# --------------------------------------------------------------------------
#
# source://logging//lib/logging/utils.rb#70
class File < ::IO
  # Returns <tt>true</tt> if another process holds an exclusive lock on the
  # file. Returns <tt>false</tt> if this is not the case.
  #
  # If a <tt>block</tt> of code is passed to this method, it will be run iff
  # this process can obtain an exclusive lock on the file. The block will be
  # run while this lock is held, and the exclusive lock will be released when
  # the method returns.
  #
  # The exclusive lock is requested in a non-blocking mode. This method will
  # return immediately (and the block will not be executed) if an exclusive
  # lock cannot be obtained.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/utils.rb#84
  def flock?; end

  # Execute a <tt>block</tt> in the context of a shared lock on this file. A
  # shared lock will be obtained on the file, the block executed, and the lock
  # released.
  #
  # source://logging//lib/logging/utils.rb#100
  def flock_sh; end
end

# --------------------------------------------------------------------------
#
# source://logging//lib/logging/utils.rb#120
module FileUtils
  private

  # Concatenate the contents of the _src_ file to the end of the _dest_ file.
  # If the _dest_ file does not exist, then the _src_ file is copied to the
  # _dest_ file using +copy_file+.
  #
  # source://logging//lib/logging/utils.rb#126
  def concat(src, dest); end

  class << self
    # Concatenate the contents of the _src_ file to the end of the _dest_ file.
    # If the _dest_ file does not exist, then the _src_ file is copied to the
    # _dest_ file using +copy_file+.
    #
    # source://logging//lib/logging/utils.rb#126
    def concat(src, dest); end
  end
end

# source://logging//lib/logging.rb#11
HAVE_SYSLOG = T.let(T.unsafe(nil), TrueClass)

# source://logging//lib/logging.rb#18
module Logging
  extend ::LittlePlugger
  extend ::LittlePlugger::ClassMethods

  class << self
    # Access to the appenders.
    #
    # source://logging//lib/logging.rb#139
    def appenders; end

    # call-seq:
    #    Logging.backtrace             #=> true or false
    #    Logging.backtrace( value )    #=> true or false
    #
    # Without any arguments, returns the global exception backtrace logging
    # value. When set to +true+ backtraces will be written to the logs; when
    # set to +false+ backtraces will be suppressed.
    #
    # When an argument is given the global exception backtrace setting will
    # be changed. Value values are <tt>"on"</tt>, <tt>:on<tt> and +true+ to
    # turn on backtraces and <tt>"off"</tt>, <tt>:off</tt> and +false+ to
    # turn off backtraces.
    #
    # source://logging//lib/logging.rb#307
    def backtrace(b = T.unsafe(nil)); end

    # Returns the value of attribute basepath.
    #
    # source://logging//lib/logging.rb#385
    def basepath; end

    # Used to define a `basepath` that will be removed from filenames when
    # reporting tracing information for log events. Normally you would set this
    # to the root of your project:
    #
    #   Logging.basepath = "/home/user/nifty_project"
    #
    # Or if you are in a Rails environment:
    #
    #   Logging.basepath = Rails.root.to_s
    #
    # The basepath is expanded to a full path with trailing slashes removed.
    # This setting will be cleared by a call to `Logging.reset`.
    #
    # source://logging//lib/logging.rb#377
    def basepath=(path); end

    # Returns the value of attribute cause_depth.
    #
    # source://logging//lib/logging.rb#363
    def cause_depth; end

    # Set the default Exception#cause depth used when formatting Exceptions.
    # This sets the maximum number of nested errors that will be formatted by
    # the layouts before giving up. This is used to avoid extremely large
    # outputs.
    #
    #   Logging.cause_depth = nil    # set to the DEFAULT_CAUSE_DEPTH
    #   Logging.cause_depth = 0      # do not show any exception causes
    #   Logging.cause_depth = 1024   # show up to 1024 causes
    #   Logging.cause_depth = -1     # results in the DEFAULT_CAUSE_DEPTH
    #
    # source://logging//lib/logging.rb#354
    def cause_depth=(value); end

    # Public: Convenience method that will clear both the Mapped Diagnostic
    # Context and the Nested Diagnostic Context of the current thread. If the
    # `all` flag passed to this method is true, then the diagnostic contexts for
    # _every_ thread in the application will be cleared.
    #
    # all - Boolean flag used to clear the context of every Thread (default is false)
    #
    # Returns the Logging module.
    #
    # source://logging//lib/logging/diagnostic_context.rb#397
    def clear_diagnostic_contexts(all = T.unsafe(nil)); end

    # Returns the color scheme identified by the given _name_. If there is no
    # color scheme +nil+ is returned.
    #
    # If color scheme options are supplied then a new color scheme is created.
    # Any existing color scheme with the given _name_ will be replaced by the
    # new color scheme.
    #
    # source://logging//lib/logging.rb#150
    def color_scheme(name, opts = T.unsafe(nil)); end

    # call-seq:
    #    Logging.format_as( obj_format )
    #
    # Defines the default _obj_format_ method to use when converting objects
    # into string representations for logging. _obj_format_ can be one of
    # <tt>:string</tt>, <tt>:inspect</tt>, <tt>:json</tt> or <tt>:yaml</tt>.
    # These formatting commands map to the following object methods
    #
    # * :string  => to_s
    # * :inspect => inspect
    # * :yaml    => to_yaml
    # * :json    => MultiJson.encode(obj)
    #
    # An +ArgumentError+ is raised if anything other than +:string+,
    # +:inspect+, +:json+ or +:yaml+ is passed to this method.
    #
    # source://logging//lib/logging.rb#283
    def format_as(f); end

    # call-seq:
    #    include Logging.globally
    #    include Logging.globally( :logger )
    #
    # Add a "logger" method to the including context. If included from
    # Object or Kernel, the logger method will be available to all objects.
    #
    # Optionally, a method name can be given and that will be used to
    # provided access to the logger:
    #
    #    include Logging.globally( :log )
    #    log.info "Just using a shorter method name"
    #
    # If you prefer to use the shorter "log" to access the logger.
    #
    # ==== Example
    #
    #   include Logging.globally
    #
    #   class Foo
    #     logger.debug "Loading the Foo class"
    #     def initialize
    #       logger.info "Creating some new foo"
    #     end
    #   end
    #
    #   logger.fatal "End of example"
    #
    # source://logging//lib/logging.rb#196
    def globally(name = T.unsafe(nil)); end

    # call-seq:
    #    Logging.init( levels )
    #
    # Defines the levels available to the loggers. The _levels_ is an array
    # of strings and symbols. Each element in the array is downcased and
    # converted to a symbol; these symbols are used to create the logging
    # methods in the loggers.
    #
    # The first element in the array is the lowest logging level. Setting the
    # logging level to this value will enable all log messages. The last
    # element in the array is the highest logging level. Setting the logging
    # level to this value will disable all log messages except this highest
    # level.
    #
    # This method should be invoked only once to configure the logging
    # levels. It is automatically invoked with the default logging levels
    # when the first logger is created.
    #
    # The levels "all" and "off" are reserved and will be ignored if passed
    # to this method.
    #
    # Example:
    #
    #    Logging.init :debug, :info, :warn, :error, :fatal
    #    log = Logging::Logger['my logger']
    #    log.level = :warn
    #    log.warn 'Danger! Danger! Will Robinson'
    #    log.info 'Just FYI'                        # => not logged
    #
    # or
    #
    #    Logging.init %w(DEBUG INFO NOTICE WARNING ERR CRIT ALERT EMERG)
    #    log = Logging::Logger['syslog']
    #    log.level = :notice
    #    log.warning 'This is your first warning'
    #    log.info 'Just FYI'                        # => not logged
    #
    # source://logging//lib/logging.rb#239
    def init(*args); end

    # Return +true+ if the Logging framework is initialized.
    #
    # @return [Boolean]
    #
    # source://logging//lib/logging.rb#566
    def initialized?; end

    # Access to the layouts.
    #
    # source://logging//lib/logging.rb#133
    def layouts; end

    # Convert the given level into a level number.
    #
    # source://logging//lib/logging.rb#519
    def level_num(level); end

    # :stopdoc:
    # Convert the given level into a canonical form - a lowercase string.
    #
    # source://logging//lib/logging.rb#511
    def levelify(level); end

    # Returns the library path for the module. If any arguments are given,
    # they will be joined to the end of the library path using
    # <tt>File.join</tt>.
    #
    # source://logging//lib/logging.rb#391
    def libpath(*args, &block); end

    # Internal logging method for use by the framework.
    #
    # source://logging//lib/logging.rb#528
    def log_internal(level = T.unsafe(nil), &block); end

    # Internal logging method for handling exceptions. If the
    # `Thread#abort_on_exception` flag is set then the
    # exception will be raised again.
    #
    # source://logging//lib/logging.rb#535
    def log_internal_error(err); end

    # call-seq:
    #    Logging.logger( device, age = 7, size = 1048576 )
    #    Logging.logger( device, age = 'weekly' )
    #
    # This convenience method returns a Logger instance configured to behave
    # similarly to a core Ruby Logger instance.
    #
    # The _device_ is the logging destination. This can be a filename
    # (String) or an IO object (STDERR, STDOUT, an open File, etc.). The
    # _age_ is the number of old log files to keep or the frequency of
    # rotation (+daily+, +weekly+, or +monthly+). The _size_ is the maximum
    # logfile size and is only used when _age_ is a number.
    #
    # Using the same _device_ twice will result in the same Logger instance
    # being returned. For example, if a Logger is created using STDOUT then
    # the same Logger instance will be returned the next time STDOUT is
    # used. A new Logger instance can be obtained by closing the previous
    # logger instance.
    #
    #    log1 = Logging.logger(STDOUT)
    #    log2 = Logging.logger(STDOUT)
    #    log1.object_id == log2.object_id  #=> true
    #
    #    log1.close
    #    log2 = Logging.logger(STDOUT)
    #    log1.object_id == log2.object_id  #=> false
    #
    # The format of the log messages can be changed using a few optional
    # parameters. The <tt>:pattern</tt> can be used to change the log
    # message format. The <tt>:date_pattern</tt> can be used to change how
    # timestamps are formatted.
    #
    #    log = Logging.logger(STDOUT,
    #              :pattern => "[%d] %-5l : %m\n",
    #              :date_pattern => "%Y-%m-%d %H:%M:%S.%s")
    #
    # See the documentation for the Logging::Layouts::Pattern class for a
    # full description of the :pattern and :date_pattern formatting strings.
    #
    # source://logging//lib/logging.rb#72
    def logger(*args); end

    # Public: Accessor method for getting the current Thread's
    # MappedDiagnosticContext.
    #
    # Returns MappedDiagnosticContext
    #
    # source://logging//lib/logging/diagnostic_context.rb#379
    def mdc; end

    # Public: Accessor method for getting the current Thread's
    # NestedDiagnosticContext.
    #
    # Returns NestedDiagnosticContext
    #
    # source://logging//lib/logging/diagnostic_context.rb#386
    def ndc; end

    # Returns the lpath for the module. If any arguments are given,
    # they will be joined to the end of the path using
    # <tt>File.join</tt>.
    #
    # source://logging//lib/logging.rb#408
    def path(*args, &block); end

    # Raise an exception when an error is encountered while logging, be it with
    # a backing store, formatter, or anything else. You probably wouldn't want
    # to enable this outside of test.
    #
    # Not that only one error will ever be raised per logging backend, as
    # backends that raise errors on write will be set to :off.
    #
    # source://logging//lib/logging.rb#500
    def raise_errors=(boolean); end

    # Whether or not we should raise errors when writing logs.
    #
    # @return [Boolean]
    #
    # source://logging//lib/logging.rb#505
    def raise_errors?; end

    # Reopen all appenders. This method should be called immediately after a
    # fork to ensure no conflict with file descriptors and calls to fcntl or
    # flock.
    #
    # source://logging//lib/logging.rb#162
    def reopen; end

    # Reset the Logging framework to it's uninitialized state
    #
    # source://logging//lib/logging.rb#549
    def reset; end

    # call-seq:
    #    show_configuration( io = STDOUT, logger = 'root' )
    #
    # This method is used to show the configuration of the logging
    # framework. The information is written to the given _io_ stream
    # (defaulting to stdout). Normally the configuration is dumped starting
    # with the root logger, but any logger name can be given.
    #
    # Each line contains information for a single logger and it's appenders.
    # A child logger is indented two spaces from it's parent logger. Each
    # line contains the logger name, level, additivity, and trace settings.
    # Here is a brief example:
    #
    #    root  ...........................   *info      -T
    #      LoggerA  ......................    info  +A  -T
    #        LoggerA::LoggerB  ...........    info  +A  -T
    #        LoggerA::LoggerC  ...........  *debug  +A  -T
    #      LoggerD  ......................   *warn  -A  +T
    #
    # The lines can be deciphered as follows:
    #
    #    1) name       - the name of the logger
    #
    #    2) level      - the logger level; if it is preceded by an
    #                    asterisk then the level was explicitly set for that
    #                    logger (as opposed to being inherited from the parent
    #                    logger)
    #
    #    3) additivity - a "+A" shows the logger is additive, and log events
    #                    will be passed up to the parent logger; "-A" shows
    #                    that the logger will *not* pass log events up to the
    #                    parent logger
    #
    #    4) tracing    - a "+T" shows that the logger will include caller
    #                    tracing information in generated log events (this
    #                    includes filename and line number of the log
    #                    message); "-T" shows that the logger does not include
    #                    caller tracing information in the log events
    #
    # If a logger has appenders then they are listed, one per line,
    # immediately below the logger. Appender lines are pre-pended with a
    # single dash:
    #
    #    root  ...........................   *info      -T
    #    - <Appenders::Stdout:0x8b02a4 name="stdout">
    #      LoggerA  ......................    info  +A  -T
    #        LoggerA::LoggerB  ...........    info  +A  -T
    #        LoggerA::LoggerC  ...........  *debug  +A  -T
    #      LoggerD  ......................   *warn  -A  +T
    #      - <Appenders::Stderr:0x8b04ca name="stderr">
    #
    # We can see in this configuration dump that all the loggers will append
    # to stdout via the Stdout appender configured in the root logger. All
    # the loggers are additive, and so their generated log events will be
    # passed up to the root logger.
    #
    # The exception in this configuration is LoggerD. Its additivity is set
    # to false. It uses its own appender to send messages to stderr.
    #
    # source://logging//lib/logging.rb#480
    def show_configuration(io = T.unsafe(nil), logger = T.unsafe(nil), indent = T.unsafe(nil)); end

    # Close all appenders
    #
    # source://logging//lib/logging.rb#541
    def shutdown(*args); end

    # Returns the value of attribute utc_offset.
    #
    # source://logging//lib/logging.rb#342
    def utc_offset; end

    # Set the default UTC offset used when formatting time values sent to the
    # appenders. If left unset, the default local time zone will be used for
    # time values. This method accepts the `utc_offset` format supported by the
    # `Time#localtime` method in Ruby.
    #
    # Passing "UTC" or `0` as the UTC offset will cause all times to be reported
    # in the UTC timezone.
    #
    #   Logging.utc_offset = "-07:00"  # Mountain Standard Time in North America
    #   Logging.utc_offset = "+01:00"  # Central European Time
    #   Logging.utc_offset = "UTC"     # UTC
    #   Logging.utc_offset = 0         # UTC
    #
    # source://logging//lib/logging.rb#332
    def utc_offset=(value); end

    # Returns the version string for the library.
    #
    # source://logging//lib/logging/version.rb#5
    def version; end
  end
end

# The +Appender+ class is provides methods for appending log events to a
# logging destination. The log events are formatted into strings using a
# Layout.
#
# All other Appenders inherit from this class which provides stub methods.
# Each subclass should provide a +write+ method that will write log
# messages to the logging destination.
#
# source://logging//lib/logging/appender.rb#12
class Logging::Appender
  # call-seq:
  #    Appender.new( name )
  #    Appender.new( name, :layout => layout )
  #
  # Creates a new appender using the given name. If no Layout is specified,
  # then a Basic layout will be used. Any logging header supplied by the
  # layout will be written to the logging destination when the Appender is
  # created.
  #
  # Options:
  #
  #    :layout   => the layout to use when formatting log events
  #    :level    => the level at which to log
  #    :encoding => encoding to use when writing messages (defaults to UTF-8)
  #    :filters  => filters to apply to events before processing
  #
  # @return [Appender] a new instance of Appender
  #
  # source://logging//lib/logging/appender.rb#32
  def initialize(name, opts = T.unsafe(nil)); end

  # call-seq:
  #    appender << string
  #
  # Write the given _string_ to the logging destination "as is" -- no
  # layout formatting will be performed.
  #
  # source://logging//lib/logging/appender.rb#91
  def <<(str); end

  # Save off the original `to_s` for use in tests
  def _to_s; end

  # Sets the filter(s) to be used by this appender. The filters will be
  # applied in the order that they are added to the appender.
  #
  # Examples
  #    add_filters(Logging::Filters::Level.new(:warn, :error))
  #
  # Returns this appender instance.
  #
  # source://logging//lib/logging/appender.rb#180
  def add_filters(*args); end

  # Check to see if the event should be processed by the appender. An event will
  # be rejected if the event level is lower than the configured level for the
  # appender. Or it will be rejected if one of the filters rejects the event.
  #
  # event - The LogEvent to check
  #
  # Returns the event if it is allowed; returns `nil` if it is not allowed.
  #
  # source://logging//lib/logging/appender.rb#289
  def allow(event); end

  # call-seq:
  #    append( event )
  #
  # Write the given _event_ to the logging destination. The log event will
  # be processed through the Layout associated with the Appender.
  #
  # source://logging//lib/logging/appender.rb#66
  def append(event); end

  # call-seq:
  #    close( footer = true )
  #
  # Close the appender and writes the layout footer to the logging
  # destination if the _footer_ flag is set to +true+. Log events will
  # no longer be written to the logging destination after the appender
  # is closed.
  #
  # source://logging//lib/logging/appender.rb#199
  def close(footer = T.unsafe(nil)); end

  # call-seq:
  #    closed?
  #
  # Returns +true+ if the appender has been closed; returns +false+
  # otherwise. When an appender is closed, no more log events can be
  # written to the logging destination.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/appender.rb#226
  def closed?; end

  # Returns the current Encoding for the appender. The default external econding
  # will be used if none is explicitly set.
  #
  # source://logging//lib/logging/appender.rb#263
  def encoding; end

  # Set the appender encoding to the given value. The value can either be an
  # Encoding instance or a String or Symbol referring to a valid encoding.
  #
  # This method only applies to Ruby 1.9 or later. The encoding will always be
  # nil for older Rubies.
  #
  # value - The encoding as a String, Symbol, or Encoding instance.
  #
  # Raises ArgumentError if the value is not a valid encoding.
  #
  # source://logging//lib/logging/appender.rb#274
  def encoding=(value); end

  # Returns the value of attribute filters.
  #
  # source://logging//lib/logging/appender.rb#14
  def filters; end

  # Sets the filter(s) to be used by this appender. This method will clear the
  # current filter set and add those passed to this setter method.
  #
  # Examples
  #    appender.filters = Logging::Filters::Level.new(:warn, :error)
  #
  # source://logging//lib/logging/appender.rb#168
  def filters=(args); end

  # call-seq:
  #    flush
  #
  # Call +flush+ to force an appender to write out any buffered log events.
  # Similar to IO#flush, so use in a similar fashion.
  #
  # source://logging//lib/logging/appender.rb#245
  def flush; end

  # Returns the value of attribute layout.
  #
  # source://logging//lib/logging/appender.rb#14
  def layout; end

  # call-seq
  #    appender.layout = Logging::Layouts::Basic.new
  #
  # Sets the layout to be used by this appender.
  #
  # source://logging//lib/logging/appender.rb#154
  def layout=(layout); end

  # Returns the value of attribute level.
  #
  # source://logging//lib/logging/appender.rb#14
  def level; end

  # call-seq:
  #    level = :all
  #
  # Set the level for this appender; log events below this level will be
  # ignored by this appender. The level can be either a +String+, a
  # +Symbol+, or an +Integer+. An +ArgumentError+ is raised if this is not
  # the case.
  #
  # There are two special levels -- "all" and "off". The former will
  # enable recording of all log events. The latter will disable the
  # recording of all events.
  #
  # Example:
  #
  #    appender.level = :debug
  #    appender.level = "INFO"
  #    appender.level = 4
  #    appender.level = 'off'
  #    appender.level = :all
  #
  # These produce an +ArgumentError+
  #
  #    appender.level = Object
  #    appender.level = -1
  #    appender.level = 1_000_000_000_000
  #
  # source://logging//lib/logging/appender.rb#133
  def level=(level); end

  # Returns the value of attribute name.
  #
  # source://logging//lib/logging/appender.rb#14
  def name; end

  # Returns `true` if the appender has been turned off. This is useful for
  # appenders that write data to a remote location (such as syslog or email),
  # and that write encounters too many errors. The appender can turn itself off
  # to and log an error via the `Logging` logger.
  #
  # Set the appender's level to a valid value to turn it back on.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/appender.rb#303
  def off?; end

  # Reopen the connection to the underlying logging destination. If the
  # connection is currently closed then it will be opened. If the connection
  # is currently open then it will be closed and immediately opened.
  #
  # source://logging//lib/logging/appender.rb#234
  def reopen; end

  # call-seq:
  #     to_s => string
  #
  # Returns a string representation of the appender.
  #
  # source://logging//lib/logging/appender.rb#257
  def to_s; end

  private

  # call-seq:
  #    write( event )
  #
  # Writes the given _event_ to the logging destination. Subclasses should
  # provide an implementation of this method. The _event_ can be either a
  # LogEvent or a String. If a LogEvent, then it will be formatted using
  # the layout given to the appender when it was created.
  #
  # source://logging//lib/logging/appender.rb#318
  def write(event); end
end

# source://logging//lib/logging/appenders.rb#3
module Logging::Appenders
  extend ::Logging::Appenders

  # call-seq:
  #    Appenders[name]
  #
  # Returns the appender instance stored in the appender hash under the
  # key _name_, or +nil+ if no appender has been created using that name.
  #
  # source://logging//lib/logging/appenders.rb#11
  def [](name); end

  # call-seq:
  #    Appenders[name] = appender
  #
  # Stores the given _appender_ instance in the appender hash under the
  # key _name_.
  #
  # source://logging//lib/logging/appenders.rb#19
  def []=(name, value); end

  # call-seq:
  #    each {|appender| block}
  #
  # Yield each appender to the _block_.
  #
  # source://logging//lib/logging/appenders.rb#34
  def each(&block); end

  # call-seq:
  #    Appenders.remove( name )
  #
  # Removes the appender instance stored in the appender hash under the
  # key _name_.
  #
  # source://logging//lib/logging/appenders.rb#27
  def remove(name); end

  # :stopdoc:
  #
  # source://logging//lib/logging/appenders.rb#40
  def reset; end

  class << self
    # Accessor / Factory for the File appender.
    #
    # source://logging//lib/logging/appenders/file.rb#5
    def file(*args); end

    # Accessor / Factory for the IO appender.
    #
    # source://logging//lib/logging/appenders/io.rb#5
    def io(*args); end

    # Accessor / Factory for the RollingFile appender.
    #
    # source://logging//lib/logging/appenders/rolling_file.rb#4
    def rolling_file(*args); end

    # Accessor / Factory for the Stderr appender.
    #
    # source://logging//lib/logging/appenders/console.rb#76
    def stderr(*args); end

    # Accessor / Factory for the Stdout appender.
    #
    # source://logging//lib/logging/appenders/console.rb#68
    def stdout(*args); end

    # Accessor / Factory for the StringIo appender.
    #
    # source://logging//lib/logging/appenders/string_io.rb#6
    def string_io(*args); end

    # Accessor / Factory for the Syslog appender.
    #
    # source://logging//lib/logging/appenders/syslog.rb#11
    def syslog(*args); end
  end
end

# The Buffering module is used to implement buffering of the log messages
# in a given appender. The size of the buffer can be specified, and the
# buffer can be configured to auto-flush at a given threshold. The
# threshold can be a single message or a very large number of messages.
#
# Log messages of a certain level can cause the buffer to be flushed
# immediately. If an error occurs, all previous messages and the error
# message will be written immediately to the logging destination if the
# buffer is configured to do so.
#
# source://logging//lib/logging/appenders/buffering.rb#14
module Logging::Appenders::Buffering
  # Setup the message buffer and other variables for automatically and
  # periodically flushing the buffer.
  #
  # source://logging//lib/logging/appenders/buffering.rb#42
  def initialize(*args, &block); end

  # When set, the buffer will be flushed using an asynchronous Thread. That
  # is, the main program thread will not be blocked during writes.
  #
  # source://logging//lib/logging/appenders/buffering.rb#32
  def async; end

  # Enable or disable asynchronous logging via a dedicated logging Thread.
  # Pass in `true` to enable and `false` to disable.
  #
  # bool - A boolean value
  #
  # source://logging//lib/logging/appenders/buffering.rb#232
  def async=(bool); end

  # When set, the buffer will be flushed using an asynchronous Thread. That
  # is, the main program thread will not be blocked during writes.
  def async?; end

  # The auto-flushing setting. When the buffer reaches this size, all
  # messages will be be flushed automatically.
  #
  # source://logging//lib/logging/appenders/buffering.rb#24
  def auto_flushing; end

  # Configure the auto-flushing threshold. Auto-flushing is used to flush
  # the contents of the logging buffer to the logging destination
  # automatically when the buffer reaches a certain threshold.
  #
  # By default, the auto-flushing will be configured to flush after each
  # log message.
  #
  # The allowed settings are as follows:
  #
  #   N      : flush after every N messages (N is an integer)
  #   true   : flush after each log message
  #   false  OR
  #   nil    OR
  #   0      : only flush when the buffer is full (500 messages)
  #
  # If the default buffer size of 500 is too small, then you can manually
  # configure it to be as large as you want. This will consume more memory.
  #
  #   auto_flushing = 42_000
  #
  # source://logging//lib/logging/appenders/buffering.rb#160
  def auto_flushing=(period); end

  # The buffer holding the log messages
  #
  # source://logging//lib/logging/appenders/buffering.rb#20
  def buffer; end

  # Clear the underlying buffer of all log events. These events will not be
  # appended to the logging destination; they will be lost.
  #
  # source://logging//lib/logging/appenders/buffering.rb#102
  def clear!; end

  # Close the message buffer by flushing all log events to the appender. If an
  # async flusher thread is running, shut it down and allow it to exit.
  #
  # source://logging//lib/logging/appenders/buffering.rb#55
  def close(*args); end

  # Call `flush` to force an appender to write out any buffered log events.
  # Similar to `IO#flush`, so use in a similar fashion.
  #
  # source://logging//lib/logging/appenders/buffering.rb#78
  def flush; end

  # When set, the buffer will be flushed at regular intervals defined by the
  # flush_period.
  #
  # source://logging//lib/logging/appenders/buffering.rb#28
  def flush_period; end

  # Configure periodic flushing of the message buffer. Periodic flushing is
  # used to flush the contents of the logging buffer at some regular
  # interval. Periodic flushing is disabled by default.
  #
  # When enabling periodic flushing the flush period should be set using one
  # of the following formats: "HH:MM:SS" or seconds as an numeric or string.
  #
  #   "01:00:00"  : every hour
  #   "00:05:00"  : every 5 minutes
  #   "00:00:30"  : every 30 seconds
  #   60          : every 60 seconds (1 minute)
  #   "120"       : every 120 seconds (2 minutes)
  #
  # For the periodic flusher to work properly, the auto-flushing threshold
  # will be set to the default value of 500. The auto-flushing threshold can
  # be changed, but it must be greater than 1.
  #
  # To disable the periodic flusher simply set the flush period to +nil+.
  # The auto-flushing threshold will not be changed; it must be disabled
  # manually if so desired.
  #
  # source://logging//lib/logging/appenders/buffering.rb#201
  def flush_period=(period); end

  # Returns `true` if an asynchronous flush period has been defined for the
  # appender.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/appenders/buffering.rb#223
  def flush_period?; end

  # Configure the levels that will trigger an immediate flush of the
  # logging buffer. When a log event of the given level is seen, the
  # buffer will be flushed immediately. Only the levels explicitly given
  # in this assignment will flush the buffer; if an "error" message is
  # configured to immediately flush the buffer, a "fatal" message will not
  # even though it is a higher level. Both must be explicitly passed to
  # this assignment.
  #
  # You can pass in a single level name or number, an array of level
  # names or numbers, or a string containing a comma separated list of level
  # names or numbers.
  #
  #   immediate_at = :error
  #   immediate_at = [:error, :fatal]
  #   immediate_at = "warn, error"
  #
  # source://logging//lib/logging/appenders/buffering.rb#122
  def immediate_at=(level); end

  # Reopen the connection to the underlying logging destination. In addition
  # if the appender is configured for asynchronous flushing, then the flushing
  # thread will be stopped and restarted.
  #
  # source://logging//lib/logging/appenders/buffering.rb#71
  def reopen; end

  # Messages will be written in chunks. This controls the number of messages
  # to pull from the buffer for each write operation. The default is to pull
  # all messages from the buffer at once.
  #
  # source://logging//lib/logging/appenders/buffering.rb#37
  def write_size; end

  # Messages will be written in chunks. This controls the number of messages
  # to pull from the buffer for each write operation. The default is to pull
  # all messages from the buffer at once.
  #
  # source://logging//lib/logging/appenders/buffering.rb#37
  def write_size=(_arg0); end

  protected

  # Configure the buffering using the arguments found in the give options
  # hash. This method must be called in order to use the message buffer.
  # The supported options are "immediate_at" and "auto_flushing". Please
  # refer to the documentation for those methods to see the allowed
  # options.
  #
  # source://logging//lib/logging/appenders/buffering.rb#247
  def configure_buffering(opts); end

  # Returns `true` if the `event` level matches one of the configured
  # immediate logging levels. Otherwise returns `false`.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/appenders/buffering.rb#259
  def immediate?(event); end

  private

  # Attempt to parse an hours/minutes/seconds value from the string and return
  # an integer number of seconds.
  #
  # str - The input String to parse for time values.
  #
  # Examples
  #
  #   _parse_hours_minutes_seconds("14:12:42")  #=> 51162
  #   _parse_hours_minutes_seconds("foo")       #=> nil
  #
  # Returns a Numeric or `nil`
  #
  # source://logging//lib/logging/appenders/buffering.rb#318
  def _parse_hours_minutes_seconds(str); end

  # Convert the string into a numeric value. If the string does not
  # represent a valid Integer or Float then `nil` is returned.
  #
  # str - The input String to parse for Numeric values.
  #
  # Examples
  #
  #   _parse_numeric("10")   #=> 10
  #   _parse_numeric("1.0")  #=> 1.0
  #   _parse_numeric("foo")  #=> nil
  #
  # Returns a Numeric or `nil`
  #
  # source://logging//lib/logging/appenders/buffering.rb#337
  def _parse_numeric(str); end

  # Using the flush_period, create a new AsyncFlusher attached to this
  # appender. If the flush_period is nil, then no action will be taken. If a
  # AsyncFlusher already exists, it will be stopped and a new one will be
  # created.
  #
  # Returns `nil`
  #
  # source://logging//lib/logging/appenders/buffering.rb#347
  def _setup_async_flusher; end

  # call-seq:
  #    write( event )
  #
  # Writes the given `event` to the logging destination. The `event` can
  # be either a LogEvent or a String. If a LogEvent, then it will be
  # formatted using the layout given to the appender when it was created.
  #
  # The `event` will be formatted and then buffered until the
  # "auto_flushing" level has been reached. At this time the canonical_write
  # method will be used to log all events stored in the buffer.
  #
  # Returns this appender instance
  #
  # source://logging//lib/logging/appenders/buffering.rb#279
  def write(event); end
end

# The AsyncFlusher contains an internal run loop that will periodically
# wake up and flush any log events contained in the message buffer of the
# owning appender instance. The AsyncFlusher relies on a `signal` from
# the appender in order to wakeup and perform the flush on the appender.
#
# source://logging//lib/logging/appenders/buffering.rb#372
class Logging::Appenders::Buffering::AsyncFlusher
  # Create a new AsyncFlusher instance that will call the `flush`
  # method on the given `appender`. The `flush` method will be called
  # every `period` seconds, but only when the message buffer is non-empty.
  #
  # appender - The Appender instance to periodically `flush`
  # period   - The Numeric sleep period or `nil`
  #
  # @return [AsyncFlusher] a new instance of AsyncFlusher
  #
  # source://logging//lib/logging/appenders/buffering.rb#381
  def initialize(appender, period); end

  # Returns `true` if the flusher should immeidately write the buffer to the
  # IO destination.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/appenders/buffering.rb#453
  def immediate?; end

  # Signal the async flusher. This will wake up the run loop if it is
  # currently waiting for something to do. If the signal method is never
  # called, the async flusher will never perform the flush action on
  # the appender.
  #
  # immediate - Set to `true` if the sleep period should be skipped
  #
  # Returns this flusher instance
  #
  # source://logging//lib/logging/appenders/buffering.rb#433
  def signal(immediate = T.unsafe(nil)); end

  # Start the periodic flusher's internal run loop.
  #
  # Returns this flusher instance
  #
  # source://logging//lib/logging/appenders/buffering.rb#396
  def start; end

  # Stop the async flusher's internal run loop.
  #
  # Returns this flusher instance
  #
  # source://logging//lib/logging/appenders/buffering.rb#417
  def stop; end

  # Returns `true` if the flusher is waiting for a signal. Returns `false`
  # if the flusher is somewhere in the processing loop.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/appenders/buffering.rb#447
  def waiting?; end

  private

  # source://logging//lib/logging/appenders/buffering.rb#459
  def _try_to_sleep; end

  # source://logging//lib/logging/appenders/buffering.rb#465
  def _wait_for_signal; end
end

# Default buffer size
#
# source://logging//lib/logging/appenders/buffering.rb#17
Logging::Appenders::Buffering::DEFAULT_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# This class is provides an Appender base class for writing to the standard IO
# stream - STDOUT and STDERR. This class should not be instantiated directly.
# The `Stdout` and `Stderr` subclasses should be used.
#
# source://logging//lib/logging/appenders/console.rb#6
class Logging::Appenders::Console < ::Logging::Appenders::IO
  # call-seq:
  #    Stdout.new( name = 'stdout' )
  #    Stderr.new( :layout => layout )
  #    Stdout.new( name = 'stdout', :level => 'info' )
  #
  # Creates a new Stdout/Stderr Appender. The name 'stdout'/'stderr' will be
  # used unless another is given. Optionally, a layout can be given for the
  # appender to use (otherwise a basic appender will be created) and a log
  # level can be specified.
  #
  # Options:
  #
  #    :layout => the layout to use when formatting log events
  #    :level  => the level at which to log
  #
  # @return [Console] a new instance of Console
  #
  # source://logging//lib/logging/appenders/console.rb#23
  def initialize(*args); end

  # Reopen the connection to the underlying logging destination. If the
  # connection is currently closed then it will be opened. If the connection
  # is currently open then it will be closed and immediately reopened.
  #
  # source://logging//lib/logging/appenders/console.rb#38
  def reopen; end

  private

  # source://logging//lib/logging/appenders/console.rb#49
  def open_fd; end
end

# This class provides an Appender that can write to a File.
#
# source://logging//lib/logging/appenders/file.rb#11
class Logging::Appenders::File < ::Logging::Appenders::IO
  # call-seq:
  #    File.new( name, :filename => 'file' )
  #    File.new( name, :filename => 'file', :truncate => true )
  #    File.new( name, :filename => 'file', :layout => layout )
  #
  # Creates a new File Appender that will use the given filename as the
  # logging destination. If the file does not already exist it will be
  # created. If the :truncate option is set to +true+ then the file will
  # be truncated before writing begins; otherwise, log messages will be
  # appended to the file.
  #
  # @raise [ArgumentError]
  # @return [File] a new instance of File
  #
  # source://logging//lib/logging/appenders/file.rb#45
  def initialize(name, opts = T.unsafe(nil)); end

  # Returns the path to the logfile.
  #
  # source://logging//lib/logging/appenders/file.rb#61
  def filename; end

  # Reopen the connection to the underlying logging destination. If the
  # connection is currently closed then it will be opened. If the connection
  # is currently open then it will be closed and immediately opened.
  #
  # source://logging//lib/logging/appenders/file.rb#66
  def reopen; end

  protected

  # source://logging//lib/logging/appenders/file.rb#99
  def create_file; end

  # source://logging//lib/logging/appenders/file.rb#92
  def open_file; end

  # source://logging//lib/logging/appenders/file.rb#81
  def truncate; end

  class << self
    # call-seq:
    #    File.assert_valid_logfile( filename )    => true
    #
    # Asserts that the given _filename_ can be used as a log file by ensuring
    # that if the file exists it is a regular file and it is writable. If
    # the file does not exist, then the directory is checked to see if it is
    # writable.
    #
    # An +ArgumentError+ is raised if any of these assertions fail.
    #
    # source://logging//lib/logging/appenders/file.rb#22
    def assert_valid_logfile(fn); end
  end
end

# This class provides an Appender that can write to any IO stream
# configured for writing.
#
# source://logging//lib/logging/appenders/io.rb#12
class Logging::Appenders::IO < ::Logging::Appender
  include ::Logging::Appenders::Buffering

  # call-seq:
  #    IO.new( name, io )
  #    IO.new( name, io, :layout => layout )
  #
  # Creates a new IO Appender using the given name that will use the _io_
  # stream as the logging destination.
  #
  # @return [IO] a new instance of IO
  #
  # source://logging//lib/logging/appenders/io.rb#26
  def initialize(name, io, opts = T.unsafe(nil)); end

  # call-seq:
  #    close( footer = true )
  #
  # Close the appender and writes the layout footer to the logging
  # destination if the _footer_ flag is set to +true+. Log events will
  # no longer be written to the logging destination after the appender
  # is closed.
  #
  # source://logging//lib/logging/appenders/io.rb#46
  def close(*args); end

  # The method that will be used to close the IO stream. Defaults to :close
  # but can be :close_read, :close_write or nil. When nil, the IO stream
  # will not be closed when the appender's close method is called.
  #
  # source://logging//lib/logging/appenders/io.rb#18
  def close_method; end

  # The method that will be used to close the IO stream. Defaults to :close
  # but can be :close_read, :close_write or nil. When nil, the IO stream
  # will not be closed when the appender's close method is called.
  #
  # source://logging//lib/logging/appenders/io.rb#18
  def close_method=(_arg0); end

  # Reopen the connection to the underlying logging destination. If the
  # connection is currently closed then it will be opened. If the connection
  # is currently open then it will be closed and immediately opened. If
  # supported, the IO will have its sync mode set to `true` so that all writes
  # are immediately flushed to the underlying operating system.
  #
  # source://logging//lib/logging/appenders/io.rb#64
  def reopen; end

  private

  # This method is called by the buffering code when messages need to be
  # written to the logging destination.
  #
  # source://logging//lib/logging/appenders/io.rb#74
  def canonical_write(str); end

  # source://logging//lib/logging/appenders/io.rb#83
  def handle_internal_error(err); end
end

# An appender that writes to a file and ensures that the file size or age
# never exceeds some user specified level.
#
# The goal of this class is to write log messages to a file. When the file
# age or size exceeds a given limit then the log file is copied and then
# truncated. The name of the copy indicates it is an older log file.
#
# The name of the log file is changed by inserting the age of the log file
# (as a single number) between the log file name and the extension. If the
# file has no extension then the number is appended to the filename. Here
# is a simple example:
#
#    /var/log/ruby.log   =>   /var/log/ruby.1.log
#
# New log messages will continue to be appended to the same log file
# (`/var/log/ruby.log` in our example above). The age number for all older
# log files is incremented when the log file is rolled. The number of older
# log files to keep can be given, otherwise all the log files are kept.
#
# The actual process of rolling all the log file names can be expensive if
# there are many, many older log files to process.
#
# If you do not wish to use numbered files when rolling, you can specify the
# :roll_by option as 'date'. This will use a date/time stamp to
# differentiate the older files from one another. If you configure your
# rolling file appender to roll daily and ignore the file size:
#
#    /var/log/ruby.log   =>   /var/log/ruby.20091225.log
#
# Where the date is expressed as `%Y%m%d` in the Time#strftime format.
#
# NOTE: this class is not safe to use when log messages are written to files
# on NFS mounts or other remote file system. It should only be used for log
# files on the local file system. The exception to this is when a single
# process is writing to the log file; remote file systems are safe to
# use in this case but still not recommended.
#
# source://logging//lib/logging/appenders/rolling_file.rb#45
class Logging::Appenders::RollingFile < ::Logging::Appenders::IO
  # call-seq:
  #    RollingFile.new( name, opts )
  #
  # Creates a new Rolling File Appender. The _name_ is the unique Appender
  # name used to retrieve this appender from the Appender hash. The only
  # required option is the filename to use for creating log files.
  #
  #  [:filename]  The base filename to use when constructing new log
  #               filenames.
  #
  # The "rolling" portion of the filename can be configured via some simple
  # pattern templates. For numbered rolling, you can use {{.%d}}
  #
  #   "logname{{.%d}}.log" => ["logname.log", "logname.1.log", "logname.2.log" ...]
  #   "logname.log{{-%d}}" => ["logname.log", "logname.log-1", "logname.log-2" ...]
  #
  # And for date rolling you can use `strftime` patterns:
  #
  #   "logname{{.%Y%m%d}}.log"            => ["logname.log, "logname.20130626.log" ...]
  #   "logname{{.%Y-%m-%dT%H:%M:%S}}.log" => ["logname.log, "logname.2013-06-26T22:03:31.log" ...]
  #
  # If the defaults suit you fine, just pass in the :roll_by option and use
  # your normal log filename without any pattern template.
  #
  # The following options are optional:
  #
  #  [:layout]    The Layout that will be used by this appender. The Basic
  #               layout will be used if none is given.
  #  [:truncate]  When set to true any existing log files will be rolled
  #               immediately and a new, empty log file will be created.
  #  [:size]      The maximum allowed size (in bytes) of a log file before
  #               it is rolled.
  #  [:age]       The maximum age (in seconds) of a log file before it is
  #               rolled. The age can also be given as 'daily', 'weekly',
  #               or 'monthly'.
  #  [:keep]      The number of rolled log files to keep.
  #  [:roll_by]   How to name the rolled log files. This can be 'number' or
  #               'date'.
  #
  # @return [RollingFile] a new instance of RollingFile
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#86
  def initialize(name, opts = T.unsafe(nil)); end

  # Returns the path to the logfile.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#123
  def filename; end

  # Reopen the connection to the underlying logging destination. If the
  # connection is currently closed then it will be opened. If the connection
  # is currently open then it will be closed and immediately opened.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#130
  def reopen; end

  private

  # Returns the modification time of the age file.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#234
  def age_fn_mtime; end

  # We use meta-programming here to define the `sufficiently_aged?` method for
  # the rolling appender. The `sufficiently_aged?` method is responsible for
  # determining if the current log file is older than the rolling criteria -
  # daily, weekly, etc.
  #
  # Returns this rolling file appender instance
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#244
  def build_singleton_methods; end

  # Write the given _event_ to the log file. The log file will be rolled
  # if the maximum file size is exceeded or if the file is older than the
  # maximum age.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#178
  def canonical_write(str); end

  # Returns the file name to use as the temporary copy location. We are
  # using copy-and-truncate semantics for rolling files so that the IO
  # file descriptor remains valid during rolling.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#162
  def copy_file; end

  # Returns the modification time of the copy file if one exists. Otherwise
  # returns `nil`.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#168
  def copy_file_mtime; end

  # Copy the contents of the logfile to another file. Truncate the logfile
  # to zero length. This method will set the roll flag so that all the
  # current logfiles will be rolled along with the copied file.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#219
  def copy_truncate; end

  # source://logging//lib/logging/appenders/rolling_file.rb#152
  def create_file; end

  # source://logging//lib/logging/appenders/rolling_file.rb#145
  def open_file; end

  # Returns +true+ if the log file needs to be rolled.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#203
  def roll_required?; end
end

# Not intended for general consumption, but the Roller class is used
# internally by the RollingFile appender to roll dem log files according
# to the user's desires.
#
# source://logging//lib/logging/appenders/rolling_file.rb#276
class Logging::Appenders::RollingFile::Roller
  # Create a new roller. See the RollingFile#initialize documentation for
  # the list of options.
  #
  # filename - the name of the file to roll
  # age      - the age of the file at which it should be rolled
  # size     - the size of the file in bytes at which it should be rolled
  # roll_by  - roll either by 'number' or 'date'
  # keep     - the number of log files to keep when rolling
  #
  # @raise [ArgumentError]
  # @return [Roller] a new instance of Roller
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#290
  def initialize(filename, age: T.unsafe(nil), size: T.unsafe(nil), roll_by: T.unsafe(nil), keep: T.unsafe(nil)); end

  # Returns the file name to use as the temporary copy location. We are
  # using copy-and-truncate semantics for rolling files so that the IO
  # file descriptor remains valid during rolling.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#338
  def copy_file; end

  # Returns the regular log file name without any roller text.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#329
  def filename; end

  # Returns the format String used to generate rolled file names.
  # Depending upon the `roll_by` type (:date or :number), this String will
  # be processed by `sprintf` or `Time#strftime`.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#356
  def format; end

  # Returns the glob pattern used to find rolled log files. We use this
  # list for pruning older log files and doing the numbered rolling.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#346
  def glob; end

  # Returns the value of attribute keep.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#325
  def keep; end

  # Returns the value of attribute roll.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#326
  def roll; end

  # Sets the attribute roll
  #
  # @param value the value to set the attribute roll to.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#326
  def roll=(_arg0); end

  # Returns the value of attribute roll_by.
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#325
  def roll_by; end

  # Roll the list of log files optionally removing older files. The "older
  # files" are determined by the mtime of the log files. So touching log
  # files or otherwise messing with them will screw this up.
  #
  # files - The Array of filename Strings
  #
  # Returns nil
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#418
  def roll_by_date(files); end

  # Roll the list of log files optionally removing older files. The "older
  # files" are determined by extracting the number from the log file name
  # and order by the number.
  #
  # files - The Array of filename Strings
  #
  # Returns nil
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#387
  def roll_by_number(files); end

  # Roll the log files. This method will collect the list of rolled files
  # and then pass that list to either `roll_by_number` or `roll_by_date`
  # to perform the actual rolling.
  #
  # Returns nil
  #
  # source://logging//lib/logging/appenders/rolling_file.rb#368
  def roll_files; end
end

# The magic regex for finding user-defined roller patterns.
#
# source://logging//lib/logging/appenders/rolling_file.rb#279
Logging::Appenders::RollingFile::Roller::RGXP = T.let(T.unsafe(nil), Regexp)

# This class provides an Appender that can write to STDERR.
#
# source://logging//lib/logging/appenders/console.rb#65
class Logging::Appenders::Stderr < ::Logging::Appenders::Console; end

# This class provides an Appender that can write to STDOUT.
#
# source://logging//lib/logging/appenders/console.rb#62
class Logging::Appenders::Stdout < ::Logging::Appenders::Console; end

# This class provides an Appender that can write to a StringIO instance.
# This is very useful for testing log message output.
#
# source://logging//lib/logging/appenders/string_io.rb#14
class Logging::Appenders::StringIo < ::Logging::Appenders::IO
  # call-seq:
  #    StringIo.new( name, opts = {} )
  #
  # Creates a new StringIo appender that will append log messages to a
  # StringIO instance.
  #
  # @return [StringIo] a new instance of StringIo
  #
  # source://logging//lib/logging/appenders/string_io.rb#25
  def initialize(name, opts = T.unsafe(nil)); end

  # Clears the internal StringIO instance. All log messages are removed
  # from the buffer.
  #
  # source://logging//lib/logging/appenders/string_io.rb#53
  def clear; end

  # source://logging//lib/logging/appenders/string_io.rb#64
  def read(*args); end

  # source://logging//lib/logging/appenders/string_io.rb#64
  def readline(*args); end

  # source://logging//lib/logging/appenders/string_io.rb#64
  def readlines(*args); end

  # Reopen the underlying StringIO instance. If the instance is currently
  # closed then it will be opened. If the instance is currently open then it
  # will be closed and immediately opened.
  #
  # source://logging//lib/logging/appenders/string_io.rb#36
  def reopen; end

  # Clears the internal StringIO instance. All log messages are removed
  # from the buffer.
  #
  # source://logging//lib/logging/appenders/string_io.rb#53
  def reset; end

  # The StringIO instance the appender is writing to.
  #
  # source://logging//lib/logging/appenders/string_io.rb#17
  def sio; end
end

# :stopdoc:
#
# source://logging//lib/logging/appenders/string_io.rb#80
module Logging::Appenders::StringIo::IoToS
  # source://logging//lib/logging/appenders/string_io.rb#81
  def to_s; end
end

# This class provides an Appender that can write to the UNIX syslog
# daemon.
#
# source://logging//lib/logging/appenders/syslog.rb#19
class Logging::Appenders::Syslog < ::Logging::Appender
  include ::Syslog::Option
  include ::Syslog::Facility
  include ::Syslog::Level
  include ::Syslog::Macros
  include ::Syslog::Constants
  extend ::Syslog::Macros

  # call-seq:
  #    Syslog.new( name, opts = {} )
  #
  # Create an appender that will log messages to the system message
  # logger. The message is then written to the system console, log files,
  # logged-in users, or forwarded to other machines as appropriate. The
  # options that can be used to configure the appender are as follows:
  #
  #    :ident     => identifier string (name is used by default)
  #    :logopt    => options used when opening the connection
  #    :facility  => the syslog facility to use
  #
  # The parameter :ident is a string that will be prepended to every
  # message. The :logopt argument is a bit field specifying logging
  # options, which is formed by OR'ing one or more of the following
  # values:
  #
  #    LOG_CONS      If syslog() cannot pass the message to syslogd(8) it
  #                  wil attempt to write the message to the console
  #                  ('/dev/console').
  #
  #    LOG_NDELAY    Open the connection to syslogd(8) immediately. Normally
  #                  the open is delayed until the first message is logged.
  #                  Useful for programs that need to manage the order in
  #                  which file descriptors are allocated.
  #
  #    LOG_PERROR    Write the message to standard error output as well to
  #                  the system log.  Not available on Solaris.
  #
  #    LOG_PID       Log the process id with each message: useful for
  #                  identifying instantiations of daemons.
  #
  # The :facility parameter encodes a default facility to be assigned to
  # all messages that do not have an explicit facility encoded:
  #
  #    LOG_AUTH      The authorization system: login(1), su(1), getty(8),
  #                  etc.
  #
  #    LOG_AUTHPRIV  The same as LOG_AUTH, but logged to a file readable
  #                  only by selected individuals.
  #
  #    LOG_CONSOLE   Messages written to /dev/console by the kernel console
  #                  output driver.
  #
  #    LOG_CRON      The cron daemon: cron(8).
  #
  #    LOG_DAEMON    System daemons, such as routed(8), that are not
  #                  provided for explicitly by other facilities.
  #
  #    LOG_FTP       The file transfer protocol daemons: ftpd(8), tftpd(8).
  #
  #    LOG_KERN      Messages generated by the kernel. These cannot be
  #                  generated by any user processes.
  #
  #    LOG_LPR       The line printer spooling system: lpr(1), lpc(8),
  #                  lpd(8), etc.
  #
  #    LOG_MAIL      The mail system.
  #
  #    LOG_NEWS      The network news system.
  #
  #    LOG_SECURITY  Security subsystems, such as ipfw(4).
  #
  #    LOG_SYSLOG    Messages generated internally by syslogd(8).
  #
  #    LOG_USER      Messages generated by random user processes. This is
  #                  the default facility identifier if none is specified.
  #
  #    LOG_UUCP      The uucp system.
  #
  #    LOG_LOCAL0    Reserved for local use. Similarly for LOG_LOCAL1
  #                  through LOG_LOCAL7.
  #
  # @return [Syslog] a new instance of Syslog
  #
  # source://logging//lib/logging/appenders/syslog.rb#95
  def initialize(name, opts = T.unsafe(nil)); end

  # call-seq:
  #    close
  #
  # Closes the connection to the syslog facility.
  #
  # source://logging//lib/logging/appenders/syslog.rb#139
  def close(footer = T.unsafe(nil)); end

  # call-seq:
  #    closed?    => true or false
  #
  # Queries the connection to the syslog facility and returns +true+ if
  # the connection is closed.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/appenders/syslog.rb#151
  def closed?; end

  # call-seq:
  #    map = { logging_levels => syslog_levels }
  #
  # Configure the mapping from the Logging levels to the syslog levels.
  # This is needed in order to log events at the proper syslog level.
  #
  # Without any configuration, the following mapping will be used:
  #
  #    :debug  =>  LOG_DEBUG
  #    :info   =>  LOG_INFO
  #    :warn   =>  LOG_WARNING
  #    :error  =>  LOG_ERR
  #    :fatal  =>  LOG_CRIT
  #
  # source://logging//lib/logging/appenders/syslog.rb#125
  def map=(levels); end

  # Reopen the connection to the underlying logging destination. If the
  # connection is currently closed then it will be opened. If the connection
  # is currently open then it will be closed and immediately opened.
  #
  # source://logging//lib/logging/appenders/syslog.rb#159
  def reopen; end

  private

  # call-seq:
  #    syslog_level_num( level )    => integer
  #
  # Takes the given _level_ as a string, symbol, or integer and returns
  # the corresponding syslog level number.
  #
  # source://logging//lib/logging/appenders/syslog.rb#201
  def syslog_level_num(level); end

  # call-seq:
  #    write( event )
  #
  # Write the given _event_ to the syslog facility. The log event will be
  # processed through the Layout associated with this appender. The message
  # will be logged at the level specified by the event.
  #
  # source://logging//lib/logging/appenders/syslog.rb#181
  def write(event); end
end

# ColorScheme objects encapsulate a named set of colors to be used in the
# colors() method call. For example, by applying a ColorScheme that
# has a <tt>:warning</tt> color then the following could be used:
#
#   scheme.color("This is a warning", :warning)
#
# ColorScheme objects are used by the Pattern layout code to colorize log
# messages. Each color scheme is given a unique name which is used by the
# Pattern layout to lookup the appropriate color scheme to use. Please
# refer to the Pattern layout documentation for more details - specifically
# the initializer documentation.
#
# The color scheme can be applied to the Pattern layout in several ways.
# Each token in the log pattern can be colorized with the log level (debug,
# info, warn, etc) receiving unique colors based on the level itself.
# Another option is to colorize the entire log message based on the log
# level; in this mode tokens do not get their own colors. Please see the
# ColorScheme initializer for the list of colorization options.
#
# source://logging//lib/logging/color_scheme.rb#31
class Logging::ColorScheme
  # Create a ColorScheme instance that can be accessed using the given
  # _name_. If a color scheme already exists with the given _name_ it will
  # be replaced by the new color scheme.
  #
  # The color names are passed as options to the method with each name
  # mapping to one or more color codes. For example:
  #
  #    ColorScheme.new('example', :logger => [:white, :on_green], :message => :magenta)
  #
  # The color codes are the lowercase names of the constants defined at the
  # end of this file. Multiple color codes can be aliased by grouping them
  # in an array as shown in the example above.
  #
  # Since color schemes are primarily intended to be used with the Pattern
  # layout, there are a few special options of note. First the log levels
  # are enumerated in their own hash:
  #
  #    :levels => {
  #      :debug => :blue,
  #      :info  => :cyan,
  #      :warn  => :yellow,
  #      :error => :red,
  #      :fatal => [:white, :on_red]
  #    }
  #
  # The log level token will be colorized differently based on the value of
  # the log level itself. Similarly the entire log message can be colorized
  # based on the value of the log level. A different option should be given
  # for this behavior:
  #
  #    :lines => {
  #      :debug => :blue,
  #      :info  => :cyan,
  #      :warn  => :yellow,
  #      :error => :red,
  #      :fatal => [:white, :on_red]
  #    }
  #
  # The :levels and :lines options cannot be used together; only one or the
  # other should be given.
  #
  # The remaining tokens defined in the Pattern layout can be colorized
  # using the following aliases. Their meaning in the Pattern layout are
  # repeated here for sake of clarity.
  #
  #    :logger       [%c] name of the logger that generate the log event
  #    :date         [%d] datestamp
  #    :message      [%m] the user supplied log message
  #    :pid          [%p] PID of the current process
  #    :time         [%r] the time in milliseconds since the program started
  #    :thread       [%T] the name of the thread Thread.current[:name]
  #    :thread_id    [%t] object_id of the thread
  #    :file         [%F] filename where the logging request was issued
  #    :line         [%L] line number where the logging request was issued
  #    :method       [%M] method name where the logging request was issued
  #
  # Please refer to the "examples/colorization.rb" file for a working
  # example of log colorization.
  #
  # @raise [ArgumentError]
  # @return [ColorScheme] a new instance of ColorScheme
  #
  # source://logging//lib/logging/color_scheme.rb#121
  def initialize(name, opts = T.unsafe(nil)); end

  # Allow the scheme to be accessed like a Hash.
  #
  # source://logging//lib/logging/color_scheme.rb#166
  def [](color_tag); end

  # Allow the scheme to be set like a Hash.
  #
  # source://logging//lib/logging/color_scheme.rb#172
  def []=(color_tag, constants); end

  # This method provides easy access to ANSI color sequences, without the user
  # needing to remember to CLEAR at the end of each sequence.  Just pass the
  # _string_ to color, followed by a list of _colors_ you would like it to be
  # affected by.  The _colors_ can be ColorScheme class constants, or symbols
  # (:blue for BLUE, for example).  A CLEAR will automatically be embedded to
  # the end of the returned String.
  #
  # source://logging//lib/logging/color_scheme.rb#184
  def color(string, *colors); end

  # Does this color scheme include the given tag name?
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/color_scheme.rb#160
  def include?(color_tag); end

  # Returns +true+ if the :levels option was passed to the constructor.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/color_scheme.rb#154
  def levels?; end

  # Returns +true+ if the :lines option was passed to the constructor.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/color_scheme.rb#148
  def lines?; end

  # Load multiple colors from key/value pairs.
  #
  # source://logging//lib/logging/color_scheme.rb#140
  def load_from_hash(h); end

  private

  # Return a normalized representation of a color setting.
  #
  # source://logging//lib/logging/color_scheme.rb#206
  def to_constant(v); end

  # Return a normalized representation of a color name.
  #
  # source://logging//lib/logging/color_scheme.rb#200
  def to_key(t); end

  class << self
    # Retrieve a color scheme by name.
    #
    # source://logging//lib/logging/color_scheme.rb#36
    def [](name); end

    # Store a color scheme by name.
    #
    # @raise [ArgumentError]
    #
    # source://logging//lib/logging/color_scheme.rb#42
    def []=(name, value); end

    # Clear all color schemes and setup a default color scheme.
    #
    # source://logging//lib/logging/color_scheme.rb#49
    def reset; end
  end
end

# Set the terminal's foreground ANSI color to black.
#
# source://logging//lib/logging/color_scheme.rb#225
Logging::ColorScheme::BLACK = T.let(T.unsafe(nil), String)

# The start of an ANSI blink sequence.  (Terminal support uncommon.)
#
# source://logging//lib/logging/color_scheme.rb#221
Logging::ColorScheme::BLINK = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to blue.
#
# source://logging//lib/logging/color_scheme.rb#229
Logging::ColorScheme::BLUE = T.let(T.unsafe(nil), String)

# The start of an ANSI bold sequence.
#
# source://logging//lib/logging/color_scheme.rb#217
Logging::ColorScheme::BOLD = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to bright blue.
#
# source://logging//lib/logging/color_scheme.rb#246
Logging::ColorScheme::BRIGHT_BLUE = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to bright cyan.
#
# source://logging//lib/logging/color_scheme.rb#248
Logging::ColorScheme::BRIGHT_CYAN = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to bright green.
#
# source://logging//lib/logging/color_scheme.rb#244
Logging::ColorScheme::BRIGHT_GREEN = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to bright magenta.
#
# source://logging//lib/logging/color_scheme.rb#247
Logging::ColorScheme::BRIGHT_MAGENTA = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to bright red.
#
# source://logging//lib/logging/color_scheme.rb#243
Logging::ColorScheme::BRIGHT_RED = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to bright white.
#
# source://logging//lib/logging/color_scheme.rb#249
Logging::ColorScheme::BRIGHT_WHITE = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to bright yellow.
#
# source://logging//lib/logging/color_scheme.rb#245
Logging::ColorScheme::BRIGHT_YELLOW = T.let(T.unsafe(nil), String)

# Embed in a String to clear all previous ANSI sequences.  This *MUST* be
# done before the program exits!
#
# source://logging//lib/logging/color_scheme.rb#213
Logging::ColorScheme::CLEAR = T.let(T.unsafe(nil), String)

# The start of an ANSI concealed sequence.  (Terminal support uncommon.)
#
# source://logging//lib/logging/color_scheme.rb#223
Logging::ColorScheme::CONCEALED = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to cyan.
#
# source://logging//lib/logging/color_scheme.rb#231
Logging::ColorScheme::CYAN = T.let(T.unsafe(nil), String)

# The start of an ANSI dark sequence.  (Terminal support uncommon.)
#
# source://logging//lib/logging/color_scheme.rb#218
Logging::ColorScheme::DARK = T.let(T.unsafe(nil), String)

# Erase the character under the cursor.
#
# source://logging//lib/logging/color_scheme.rb#216
Logging::ColorScheme::ERASE_CHAR = T.let(T.unsafe(nil), String)

# Erase the current line of terminal output.
#
# source://logging//lib/logging/color_scheme.rb#215
Logging::ColorScheme::ERASE_LINE = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to green.
#
# source://logging//lib/logging/color_scheme.rb#227
Logging::ColorScheme::GREEN = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to magenta.
#
# source://logging//lib/logging/color_scheme.rb#230
Logging::ColorScheme::MAGENTA = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to black.
#
# source://logging//lib/logging/color_scheme.rb#234
Logging::ColorScheme::ON_BLACK = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to blue.
#
# source://logging//lib/logging/color_scheme.rb#238
Logging::ColorScheme::ON_BLUE = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to bright blue.
#
# source://logging//lib/logging/color_scheme.rb#254
Logging::ColorScheme::ON_BRIGHT_BLUE = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to bright cyan.
#
# source://logging//lib/logging/color_scheme.rb#256
Logging::ColorScheme::ON_BRIGHT_CYAN = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to bright green.
#
# source://logging//lib/logging/color_scheme.rb#252
Logging::ColorScheme::ON_BRIGHT_GREEN = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to bright magenta.
#
# source://logging//lib/logging/color_scheme.rb#255
Logging::ColorScheme::ON_BRIGHT_MAGENTA = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to bright red.
#
# source://logging//lib/logging/color_scheme.rb#251
Logging::ColorScheme::ON_BRIGHT_RED = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to bright white.
#
# source://logging//lib/logging/color_scheme.rb#257
Logging::ColorScheme::ON_BRIGHT_WHITE = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to bright yellow.
#
# source://logging//lib/logging/color_scheme.rb#253
Logging::ColorScheme::ON_BRIGHT_YELLOW = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to cyan.
#
# source://logging//lib/logging/color_scheme.rb#240
Logging::ColorScheme::ON_CYAN = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to green.
#
# source://logging//lib/logging/color_scheme.rb#236
Logging::ColorScheme::ON_GREEN = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to magenta.
#
# source://logging//lib/logging/color_scheme.rb#239
Logging::ColorScheme::ON_MAGENTA = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to red.
#
# source://logging//lib/logging/color_scheme.rb#235
Logging::ColorScheme::ON_RED = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to white.
#
# source://logging//lib/logging/color_scheme.rb#241
Logging::ColorScheme::ON_WHITE = T.let(T.unsafe(nil), String)

# Set the terminal's background ANSI color to yellow.
#
# source://logging//lib/logging/color_scheme.rb#237
Logging::ColorScheme::ON_YELLOW = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to red.
#
# source://logging//lib/logging/color_scheme.rb#226
Logging::ColorScheme::RED = T.let(T.unsafe(nil), String)

# An alias for CLEAR.
#
# source://logging//lib/logging/color_scheme.rb#214
Logging::ColorScheme::RESET = T.let(T.unsafe(nil), String)

# The start of an ANSI reverse sequence.
#
# source://logging//lib/logging/color_scheme.rb#222
Logging::ColorScheme::REVERSE = T.let(T.unsafe(nil), String)

# The start of an ANSI underline sequence.
#
# source://logging//lib/logging/color_scheme.rb#219
Logging::ColorScheme::UNDERLINE = T.let(T.unsafe(nil), String)

# An alias for UNDERLINE.
#
# source://logging//lib/logging/color_scheme.rb#220
Logging::ColorScheme::UNDERSCORE = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to white.
#
# source://logging//lib/logging/color_scheme.rb#232
Logging::ColorScheme::WHITE = T.let(T.unsafe(nil), String)

# Set the terminal's foreground ANSI color to yellow.
#
# source://logging//lib/logging/color_scheme.rb#228
Logging::ColorScheme::YELLOW = T.let(T.unsafe(nil), String)

# source://logging//lib/logging.rb#26
Logging::DEFAULT_CAUSE_DEPTH = T.let(T.unsafe(nil), Integer)

# source://logging//lib/logging/diagnostic_context.rb#414
Logging::DIAGNOSTIC_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# The `Filter` class allows for filtering messages based on event
# properties independently of the standard minimum-level restriction.
#
# All other Filters inherit from this class, and must override the
# `allow` method to return the event if it should be allowed into the log.
# Otherwise the `allow` method should return `nil`.
#
# source://logging//lib/logging/filter.rb#9
class Logging::Filter
  # Creates a new level filter that will pass all log events. Create a
  # subclass and override the `allow` method to filter log events.
  #
  # @return [Filter] a new instance of Filter
  #
  # source://logging//lib/logging/filter.rb#13
  def initialize; end

  # Returns the event if it should be forwarded to the logging appender.
  # Returns `nil` if the event should _not_ be forwarded to the logging
  # appender. Subclasses should override this method and provide their own
  # filtering semantics.
  #
  # source://logging//lib/logging/filter.rb#21
  def allow(event); end
end

# source://logging//lib/logging/filters.rb#2
module Logging::Filters; end

# The `Level` filter class provides a simple level-based filtering mechanism
# that allows events whose log level matches a preconfigured list of values.
#
# source://logging//lib/logging/filters/level.rb#8
class Logging::Filters::Level < ::Logging::Filter
  # Creates a new level filter that will only allow the given _levels_ to
  # propagate through to the logging destination. The _levels_ should be
  # given in symbolic form.
  #
  # Examples
  #     Logging::Filters::Level.new(:debug, :info)
  #
  # @return [Level] a new instance of Level
  #
  # source://logging//lib/logging/filters/level.rb#17
  def initialize(*levels); end

  # Returns the event if it should be forwarded to the logging appender.
  # Otherwise, `nil` is returned. The log event is allowed if the
  # `event.level` matches one of the levels provided to the filter when it
  # was constructred.
  #
  # source://logging//lib/logging/filters/level.rb#27
  def allow(event); end
end

# :stopdoc:
#
# source://logging//lib/logging/diagnostic_context.rb#418
Logging::INHERIT_CONTEXT = T.let(T.unsafe(nil), TrueClass)

# source://logging//lib/logging.rb#24
Logging::LEVELS = T.let(T.unsafe(nil), Hash)

# :stopdoc:
#
# source://logging//lib/logging.rb#22
Logging::LIBPATH = T.let(T.unsafe(nil), String)

# source://logging//lib/logging.rb#25
Logging::LNAMES = T.let(T.unsafe(nil), Array)

# The +Layout+ class provides methods for formatting log events into a
# string representation. Layouts are used by Appenders to format log
# events before writing them to the logging destination.
#
# All other Layouts inherit from this class which provides stub methods.
# Each subclass should provide a +format+ method. A layout can be used by
# more than one +Appender+ so all the methods need to be thread safe.
#
# source://logging//lib/logging/layout.rb#12
class Logging::Layout
  # call-seq:
  #    Layout.new( :format_as => :string )
  #
  # Creates a new layout that will format objects as strings using the
  # given <tt>:format_as</tt> style. This can be one of <tt>:string</tt>,
  # <tt>:inspect</tt>, or <tt>:yaml</tt>. These formatting commands map to
  # the following object methods:
  #
  # * :string  => to_s
  # * :inspect => inspect
  # * :yaml    => to_yaml
  # * :json    => MultiJson.encode(obj)
  #
  # If the format is not specified then the global object format is used
  # (see Logging#format_as). If the global object format is not specified
  # then <tt>:string</tt> is used.
  #
  # @return [Layout] a new instance of Layout
  #
  # source://logging//lib/logging/layout.rb#31
  def initialize(opts = T.unsafe(nil)); end

  # Internal: Helper method that applies the UTC offset to the given `time`
  # instance. A new Time is returned that is equivalent to the original `time`
  # but pinned to the timezone given by the UTC offset.
  #
  # If a UTC offset has not been set, then the original `time` instance is
  # returned unchanged.
  #
  # source://logging//lib/logging/layout.rb#114
  def apply_utc_offset(time); end

  # Returns the backtrace setting.
  #
  # source://logging//lib/logging/layout.rb#65
  def backtrace; end

  # call-seq:
  #    layout.backtrace = true
  #
  # Set the backtrace flag to the given value. This can be set to `true` or
  # `false`.
  #
  # source://logging//lib/logging/layout.rb#55
  def backtrace=(value); end

  # Returns the backtrace setting.
  #
  # source://logging//lib/logging/layout.rb#65
  def backtrace?; end

  # Returns the exception cause depth formatting limit.
  #
  # source://logging//lib/logging/layout.rb#105
  def cause_depth; end

  # source://logging//lib/logging/layout.rb#95
  def cause_depth=(value); end

  # call-seq:
  #    footer
  #
  # Returns a footer string to be used at the end of a logging appender.
  #
  # source://logging//lib/logging/layout.rb#147
  def footer; end

  # call-seq:
  #    format( event )
  #
  # Returns a string representation of the given logging _event_. It is
  # up to subclasses to implement this method.
  #
  # source://logging//lib/logging/layout.rb#132
  def format(event); end

  # Internal: Format any nested exceptions found in the given exception `e`
  # while respecting the maximum `cause_depth`. The lines array is used to
  # capture all the output lines form the nested exceptions; the array is later
  # joined by the `format_obj` method.
  #
  # e     - Exception to format
  # lines - Array of output lines
  #
  # Returns the input `lines` Array
  #
  # source://logging//lib/logging/layout.rb#185
  def format_cause(e, lines); end

  # Internal: Format the backtrace of the nested `cause` but remove the common
  # exception lines from the parent exception. This helps keep the backtraces a
  # wee bit shorter and more comprehensible.
  #
  # e     - parent exception
  # cause - the nested exception generating the returned backtrace
  #
  # Returns an Array of backtracke lines.
  #
  # source://logging//lib/logging/layout.rb#214
  def format_cause_backtrace(e, cause); end

  # call-seq:
  #    format_obj( obj )
  #
  # Return a string representation of the given object. Depending upon
  # the configuration of the logger system the format will be an +inspect+
  # based representation or a +yaml+ based representation.
  #
  # source://logging//lib/logging/layout.rb#156
  def format_obj(obj); end

  # call-seq:
  #    header
  #
  # Returns a header string to be used at the beginning of a logging
  # appender.
  #
  # source://logging//lib/logging/layout.rb#140
  def header; end

  # Attempt to format the given object as a JSON string, but fall back to
  # inspect formatting if JSON encoding fails.
  #
  # obj - The Object to format.
  #
  # Returns a String representation of the object.
  #
  # source://logging//lib/logging/layout.rb#254
  def try_json(obj); end

  # Attempt to format the _obj_ using yaml, but fall back to inspect style
  # formatting if yaml fails.
  #
  # obj - The Object to format.
  #
  # Returns a String representation of the object.
  #
  # source://logging//lib/logging/layout.rb#241
  def try_yaml(obj); end

  # Returns the UTC offset.
  #
  # source://logging//lib/logging/layout.rb#91
  def utc_offset; end

  # Set the UTC offset used when formatting time values. If left unset, the
  # default local time zone will be used for time values. This method accepts
  # the `utc_offset` format supported by the `Time#localtime` method in Ruby.
  #
  # Passing "UTC" or `0` as the UTC offset will cause all times to be reported
  # in the UTC timezone.
  #
  #   layout.utc_offset = "-07:00"  # Mountain Standard Time in North America
  #   layout.utc_offset = "+01:00"  # Central European Time
  #   layout.utc_offset = "UTC"     # UTC
  #   layout.utc_offset = 0         # UTC
  #
  # source://logging//lib/logging/layout.rb#80
  def utc_offset=(value); end
end

# source://logging//lib/logging/layouts.rb#3
module Logging::Layouts
  class << self
    # Accessor / Factory for the Basic layout.
    #
    # source://logging//lib/logging/layouts/basic.rb#6
    def basic(*args); end

    # Factory for the Parseable layout using JSON formatting.
    #
    # source://logging//lib/logging/layouts/parseable.rb#13
    def json(*args); end

    # Accessor for the Parseable layout.
    #
    # source://logging//lib/logging/layouts/parseable.rb#7
    def parseable; end

    # Accessor / Factory for the Pattern layout.
    #
    # Returns a new Pattern layout instance
    #
    # source://logging//lib/logging/layouts/pattern.rb#6
    def pattern(*args); end

    # Factory for the Parseable layout using YAML formatting.
    #
    # source://logging//lib/logging/layouts/parseable.rb#19
    def yaml(*args); end
  end
end

# The +Basic+ layout class provides methods for simple formatting of log
# events. The resulting string follows the format below.
#
#     LEVEL  LoggerName : log message
#
# _LEVEL_ is the log level of the event. _LoggerName_ is the name of the
# logger that generated the event. <em>log message</em> is the message
# or object that was passed to the logger. If multiple message or objects
# were passed to the logger then each will be printed on its own line with
# the format show above.
#
# source://logging//lib/logging/layouts/basic.rb#22
class Logging::Layouts::Basic < ::Logging::Layout
  # call-seq:
  #    format( event )
  #
  # Returns a string representation of the given logging _event_. See the
  # class documentation for details about the formatting used.
  #
  # source://logging//lib/logging/layouts/basic.rb#30
  def format(event); end
end

# This layout will produce parseable log output in either JSON or YAML
# format. This makes it much easier for machines to parse log files and
# perform analysis on those logs.
#
# The information about the log event can be configured when the layout is
# created. Any or all of the following labels can be set as the _items_ to
# log:
#
#   'logger'     Used to output the name of the logger that generated the
#                log event.
#   'timestamp'  Used to output the timestamp of the log event.
#   'level'      Used to output the level of the log event.
#   'message'    Used to output the application supplied message
#                associated with the log event.
#   'file'       Used to output the file name where the logging request
#                was issued.
#   'line'       Used to output the line number where the logging request
#                was issued.
#   'method'     Used to output the method name where the logging request
#                was issued.
#   'hostname'   Used to output the hostname
#   'pid'        Used to output the process ID of the currently running
#                program.
#   'millis'     Used to output the number of milliseconds elapsed from
#                the construction of the Layout until creation of the log
#                event.
#   'thread_id'  Used to output the object ID of the thread that generated
#                the log event.
#   'thread'     Used to output the name of the thread that generated the
#                log event. Name can be specified using Thread.current[:name]
#                notation. Output empty string if name not specified. This
#                option helps to create more human readable output for
#                multithread application logs.
#
# These items are supplied to the layout as an array of strings. The items
# 'file', 'line', and 'method' will only work if the Logger generating the
# events is configured to generate tracing information. If this is not the
# case these fields will always be empty.
#
# When configured to output log events in YAML format, each log message
# will be formatted as a hash in it's own YAML document. The hash keys are
# the name of the item, and the value is what you would expect it to be.
# Therefore, for the default set of times log message would appear as
# follows:
#
#   ---
#   timestamp: 2009-04-17T16:15:42
#   level: INFO
#   logger: Foo::Bar
#   message: this is a log message
#   ---
#   timestamp: 2009-04-17T16:15:43
#   level: ERROR
#   logger: Foo
#   message: <RuntimeError> Oooops!!
#
# The output order of the fields is not guaranteed to be the same as the
# order specified in the _items_ list. This is because Ruby hashes are not
# ordered by default (unless you're running this in Ruby 1.9).
#
# When configured to output log events in JSON format, each log message
# will be formatted as an object (in the JSON sense of the word) on it's
# own line in the log output. Therefore, to parse the output you must read
# it line by line and parse the individual objects. Taking the same
# example above the JSON output would be:
#
#   {"timestamp":"2009-04-17T16:15:42","level":"INFO","logger":"Foo::Bar","message":"this is a log message"}
#   {"timestamp":"2009-04-17T16:15:43","level":"ERROR","logger":"Foo","message":"<RuntimeError> Oooops!!"}
#
# The output order of the fields is guaranteed to be the same as the order
# specified in the _items_ list.
#
# source://logging//lib/logging/layouts/parseable.rb#95
class Logging::Layouts::Parseable < ::Logging::Layout
  # call-seq:
  #    Parseable.new( opts )
  #
  # Creates a new Parseable layout using the following options:
  #
  #    :style      => :json or :yaml
  #    :items      => %w[timestamp level logger message]
  #    :utc_offset =>  "-06:00" or -21600 or "UTC"
  #
  # @return [Parseable] a new instance of Parseable
  #
  # source://logging//lib/logging/layouts/parseable.rb#184
  def initialize(opts = T.unsafe(nil)); end

  # Internal: Format any nested exceptions found in the given exception `e`
  # while respecting the maximum `cause_depth`.
  #
  # e - Exception to format
  #
  # Returns the cause formatted as a Hash
  #
  # source://logging//lib/logging/layouts/parseable.rb#244
  def format_cause(e); end

  # Public: Take a given object and convert it into a format suitable for
  # inclusion as a log message. The conversion allows the object to be more
  # easily expressed in YAML or JSON form.
  #
  # If the object is an Exception, then this method will return a Hash
  # containing the exception class name, message, and backtrace (if any).
  #
  # obj - The Object to format
  #
  # Returns the formatted Object.
  #
  # source://logging//lib/logging/layouts/parseable.rb#219
  def format_obj(obj); end

  # Returns the value of attribute items.
  #
  # source://logging//lib/logging/layouts/parseable.rb#191
  def items; end

  # call-seq:
  #    layout.items = %w[timestamp level logger message]
  #
  # Set the log event items that will be formatted by this layout. These
  # items, and only these items, will appear in the log output.
  #
  # source://logging//lib/logging/layouts/parseable.rb#199
  def items=(ary); end

  private

  # Call the appropriate class level create format method based on the
  # style of this parseable layout.
  #
  # source://logging//lib/logging/layouts/parseable.rb#274
  def create_format_method; end

  # Convert the given `time` into an ISO8601 formatted time string.
  #
  # source://logging//lib/logging/layouts/parseable.rb#283
  def iso8601_format(time); end

  class << self
    # call-seq:
    #    Pattern.create_json_format_methods( layout )
    #
    # This method will create the +format+ method in the given Parseable
    # _layout_ based on the configured items for the layout instance.
    #
    # source://logging//lib/logging/layouts/parseable.rb#140
    def create_json_format_method(layout); end

    # call-seq:
    #    Pattern.create_yaml_format_methods( layout )
    #
    # This method will create the +format+ method in the given Parseable
    # _layout_ based on the configured items for the layout instance.
    #
    # source://logging//lib/logging/layouts/parseable.rb#122
    def create_yaml_format_method(layout); end

    # call-seq:
    #    Parseable.json( opts )
    #
    # Create a new Parseable layout that outputs log events using JSON style
    # formatting. See the initializer documentation for available options.
    #
    # source://logging//lib/logging/layouts/parseable.rb#159
    def json(opts = T.unsafe(nil)); end

    # call-seq:
    #    Parseable.yaml( opts )
    #
    # Create a new Parseable layout that outputs log events using YAML style
    # formatting. See the initializer documentation for available options.
    #
    # source://logging//lib/logging/layouts/parseable.rb#170
    def yaml(opts = T.unsafe(nil)); end
  end
end

# :stopdoc:
# Arguments to sprintf keyed to directive letters
#
# source://logging//lib/logging/layouts/parseable.rb#99
Logging::Layouts::Parseable::DIRECTIVE_TABLE = T.let(T.unsafe(nil), Hash)

# A flexible layout configurable via a conversion pattern string.
#
# The goal of this class is to format a LogEvent and return the results as
# a String. The results depend on the conversion pattern.
#
# The conversion pattern is closely related to the conversion pattern of
# the sprintf function. A conversion pattern is composed of literal text
# and format control expressions called conversion specifiers.
#
# You are free to insert any literal text within the conversion pattern.
#
# Each conversion specifier starts with a percent sign (%) and is followed
# by optional format modifiers and a conversion character. The conversion
# character specifies the type of data, e.g. logger, level, date, thread
# ID. The format modifiers control such things as field width, padding,
# left and right justification. The following is a simple example.
#
# Let the conversion pattern be "%-5l [%c]: %m\n" and assume that the
# logging environment was set to use a Pattern layout. Then the statements
#
#    root = Logging.logger[:root]
#    root.debug("Message 1")
#    root.warn("Message 2")
#
# would yield the output
#
#    DEBUG [root]: Message 1
#    WARN  [root]: Message 2
#
# Note that there is no explicit separator between text and conversion
# specifiers. The pattern parser knows when it has reached the end of a
# conversion specifier when it reads a conversion character. In the example
# above the conversion specifier %-5l means the level of the logging event
# should be left justified to a width of five characters. The recognized
# conversion characters are
#
#  [c]  Used to output the name of the logger that generated the log
#       event. Supports an optional "precision" described further below.
#  [d]  Used to output the date of the log event. The format of the
#       date is specified using the :date_pattern option when the Layout
#       is created. ISO8601 format is assumed if not date pattern is given.
#  [F]  Used to output the file name where the logging request was issued.
#  [l]  Used to output the level of the log event.
#  [L]  Used to output the line number where the logging request was
#       issued.
#  [m]  Used to output the application supplied message associated with
#       the log event.
#  [M]  Used to output the method name where the logging request was
#       issued.
#  [h]  Used to output the hostname
#  [p]  Used to output the process ID of the currently running program.
#  [r]  Used to output the number of milliseconds elapsed from the
#       construction of the Layout until creation of the log event.
#  [t]  Used to output the object ID of the thread that generated the
#       log event.
#  [T]  Used to output the name of the thread that generated the log event.
#       Name can be specified using Thread.current[:name] notation. Output
#       empty string if name not specified. This option helps to create
#       more human readable output for multi-threaded application logs.
#  [X]  Used to output values from the Mapped Diagnostic Context. Requires
#       a key name to lookup the value from the context. More details are
#       listed below.
#  [x]  Used to output values from the Nested Diagnostic Context. Supports
#       an optional context separator string. More details are listed below.
#  [%]  The sequence '%%' outputs a single percent sign.
#
# The logger name directive 'c' accepts an optional precision that will
# only print the rightmost number of name space identifiers for the logger.
# By default the logger name is printed in full. For example, for the
# logger name "Foo::Bar::Baz" the pattern %c{2} will output "Bar::Baz".
#
# The directives F, L, and M will only work if the Logger generating the
# events is configured to generate tracing information. If this is not
# the case these fields will always be empty.
#
# The directives for including diagnostic context information in the log
# messages are X and x. For the Mapped Diagnostic Context the directive must
# be accompanied by the key identifying the value to insert into the log
# message. The X directive can appear multiple times to include multiple
# values from the mapped context.
#
#   %X{Cookie}      Insert the current session cookie
#   %X{X-Session}   Insert a session identifier
#
# For the Nested Diagnostic Context you need only include the directive
# once. All contexts currently in the stack will be added to the log message
# separated by spaces. If spaces are not your style, a separator string can
# be given, too.
#
#   %x      Insert all contexts separated by spaces
#   %x{, }  Insert all contexts separate by a comma and a space
#
# By default the relevant information is output as is. However, with the
# aid of format modifiers it is possible to change the minimum field width,
# the maximum field width and justification.
#
# The optional format modifier is placed between the percent sign and the
# conversion character.
#
# The first optional format modifier is the left justification flag which
# is just the minus (-) character. Then comes the optional minimum field
# width modifier. This is a decimal constant that represents the minimum
# number of characters to output. If the data item requires fewer
# characters, it is padded on either the left or the right until the
# minimum width is reached. The default is to pad on the left (right
# justify) but you can specify right padding with the left justification
# flag. The padding character is space. If the data item is larger than the
# minimum field width, the field is expanded to accommodate the data. The
# value is never truncated.
#
# This behavior can be changed using the maximum field width modifier which
# is designated by a period followed by a decimal constant. If the data
# item is longer than the maximum field, then the extra characters are
# removed from the end of the data item.
#
# Below are various format modifier examples for the category conversion
# specifier.
#
#   %20c       Left pad with spaces if the logger name is less than 20
#              characters long
#   %-20c      Right pad with spaces if the logger name is less than 20
#              characters long
#   %.30c      Truncates the logger name if it is longer than 30 characters
#   %20.30c    Left pad with spaces if the logger name is shorter than
#              20 characters. However, if the logger name is longer than
#              30 characters, then truncate the name.
#   %-20.30c   Right pad with spaces if the logger name is shorter than
#              20 characters. However, if the logger name is longer than
#              30 characters, then truncate the name.
#
# Below are examples of some conversion patterns.
#
#    %.1l, [%d] %5l -- %c: %m\n
#
# This is how the Logger class in the Ruby standard library formats
# messages. The main difference will be in the date format (the Pattern
# Layout uses the ISO8601 date format). Set the :date_method on the
# Pattern Layout to be 'to_s' and then the date formats will agree.
#
# source://logging//lib/logging/layouts/pattern.rb#150
class Logging::Layouts::Pattern < ::Logging::Layout
  # call-seq:
  #    Pattern.new( opts )
  #
  # Creates a new Pattern layout using the following options.
  #
  #    :pattern       =>  "[%d] %-5l -- %c : %m\n"
  #    :date_pattern  =>  "%Y-%m-%d %H:%M:%S"
  #    :date_method   =>  "usec" or "to_s"
  #    :utc_offset    =>  "-06:00" or -21600 or "UTC"
  #    :color_scheme  =>  :default
  #
  # If used, :date_method will supersede :date_pattern.
  #
  # The :color_scheme is used to apply color formatting to the log messages.
  # Individual tokens can be colorized witch the level token [%l] receiving
  # distinct colors based on the level of the log event. The entire
  # generated log message can also be colorized based on the level of the
  # log event. See the ColorScheme documentation for more details.
  #
  # @return [Pattern] a new instance of Pattern
  #
  # source://logging//lib/logging/layouts/pattern.rb#219
  def initialize(opts = T.unsafe(nil)); end

  # Evaluates the given string of `code` if the singleton class of this
  # Pattern Layout object.
  #
  # Returns this Pattern Layout instance.
  #
  # source://logging//lib/logging/layouts/pattern.rb#283
  def _meta_eval(code, file = T.unsafe(nil), line = T.unsafe(nil)); end

  # Returns the value of attribute color_scheme.
  #
  # source://logging//lib/logging/layouts/pattern.rb#241
  def color_scheme; end

  # Returns the value of attribute date_method.
  #
  # source://logging//lib/logging/layouts/pattern.rb#241
  def date_method; end

  # call-seq:
  #    appender.date_method = 'to_s'
  #    appender.date_method = :usec
  #
  # Set the date method to be used when outputting timestamps in the log
  # messages. If a date method is configured, the output of that method
  # will be used in leu of the date pattern.
  #
  # source://logging//lib/logging/layouts/pattern.rb#272
  def date_method=(var); end

  # Returns the value of attribute date_pattern.
  #
  # source://logging//lib/logging/layouts/pattern.rb#241
  def date_pattern; end

  # call-seq:
  #    appender.date_pattern = "%Y-%m-%d %H:%M:%S"
  #
  # Set the date formatting pattern to be used when outputting timestamps
  # in the log messages.
  #
  # source://logging//lib/logging/layouts/pattern.rb#259
  def date_pattern=(var); end

  # Returns the value of attribute pattern.
  #
  # source://logging//lib/logging/layouts/pattern.rb#241
  def pattern; end

  # call-seq:
  #    appender.pattern = "[%d] %-5l -- %c : %m\n"
  #
  # Set the message formatting pattern to be used by the layout.
  #
  # source://logging//lib/logging/layouts/pattern.rb#248
  def pattern=(var); end

  class << self
    # call-seq:
    #    Pattern.create_date_format_methods( pl )
    #
    # This method will create the +date_format+ method in the given Pattern
    # Layout _pl_ based on the configured date pattern and/or date method
    # specified by the user.
    #
    # source://logging//lib/logging/layouts/pattern.rb#164
    def create_date_format_methods(pl); end

    # call-seq:
    #    Pattern.create_format_method( pl )
    #
    # This method will create the `format` method in the given Pattern
    # Layout `pl` based on the configured format pattern specified by the
    # user.
    #
    # source://logging//lib/logging/layouts/pattern.rb#190
    def create_format_method(pl); end
  end
end

# This class is used to build the `format` method for the Pattern layout. It
# parses the user defined pattern and emits Ruby source code (as a string)
# that can be `eval`d in the context of the Pattern layout instance.
#
# source://logging//lib/logging/layouts/pattern.rb#292
class Logging::Layouts::Pattern::FormatMethodBuilder
  # Creates the format method builder and initializes some variables from
  # the given Patter layout instance.
  #
  # pattern_layout - The Pattern Layout instance
  #
  # @return [FormatMethodBuilder] a new instance of FormatMethodBuilder
  #
  # source://logging//lib/logging/layouts/pattern.rb#350
  def initialize(pattern_layout); end

  # This method returns a String which can be `eval`d in the context of the
  # Pattern layout. When it is `eval`d, a `format` method is defined in the
  # Pattern layout.
  #
  # At the heart of the format method is `sprintf`. The conversion pattern
  # specified in the Pattern layout is parsed and converted into a format
  # string and corresponding arguments list. The format string and arguments
  # are then processed by `sprintf` to format log events.
  #
  # Returns a Ruby code as a String.
  #
  # source://logging//lib/logging/layouts/pattern.rb#385
  def build_code; end

  # This method builds the format string used by `sprintf` to format log
  # events. The conversion pattern given by the user is iteratively parsed
  # by a regular expression into separate format directives. Each directive
  # builds up the format string and the corresponding arguments list that
  # will be formatted.
  #
  # The actual building of the format string is handled by separate
  # directive specific methods. Those handlers also populate the arguments
  # list passed to `sprintf`.
  #
  # Returns the format String.
  #
  # source://logging//lib/logging/layouts/pattern.rb#412
  def build_format_string; end

  # Returns the value of attribute color_scheme.
  #
  # source://logging//lib/logging/layouts/pattern.rb#340
  def color_scheme; end

  # Returns `true` if the log messages should be colorized.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/layouts/pattern.rb#361
  def colorize?; end

  # Returns `true` if the log levels have special colorization defined.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/layouts/pattern.rb#371
  def colorize_levels?; end

  # Returns `true` if the log messages should be colorized by line.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/layouts/pattern.rb#366
  def colorize_lines?; end

  # Returns the value of attribute format_string.
  #
  # source://logging//lib/logging/layouts/pattern.rb#342
  def format_string; end

  # Handles the rest of the directives; none of these need any special
  # handling.
  #
  # format    - format String
  # directive - the directive character
  # precision - added back to the format string
  #
  # Returns nil
  #
  # source://logging//lib/logging/layouts/pattern.rb#552
  def handle_directives(format, directive, precision); end

  # Add the log event level to the `format_string` and the `sprintf_args`.
  # The color scheme is taken into account when formatting the log event
  # level.
  #
  # format    - format String
  # directive - the directive character ('l')
  # precision - added back to the format string
  #
  # Returns nil
  #
  # source://logging//lib/logging/layouts/pattern.rb#483
  def handle_level(format, directive, precision); end

  # Add the logger name to the `format_string` and the `sprintf_args`. The
  # `slice` argument is a little interesting - this is the number of logger
  # name segments to keep. If we have a logger named "Foo::Bar::Baz" and our
  # `slice` is 2, then "Bar::Baz" will appear in the generated log message.
  # So the `slice` selects the last two parts of the logger name.
  #
  # format    - format String
  # directive - the directive character ('c')
  # slice     - the number of name segments to keep
  #
  # Returns nil
  #
  # source://logging//lib/logging/layouts/pattern.rb#452
  def handle_logger(format, directive, slice); end

  # Add a Mapped Diagnostic Context to the `format_string` and the
  # `sprintf_args`. Only one MDC value is added at a time, so this directive
  # can appear multiple times using various keys.
  #
  # format    - format String
  # directive - the directive character ('X')
  # key       - which MDC value to add to the log message
  #
  # Returns nil
  #
  # @raise [ArgumentError]
  #
  # source://logging//lib/logging/layouts/pattern.rb#511
  def handle_mdc(format, directive, key); end

  # Add a Nested Diagnostic Context to the `format_string` and the
  # `sprintf_args`. Since the NDC is an Array of values, the directive will
  # appear only once in the conversion pattern. A `separator` is inserted
  # between the values in generated log message.
  #
  # format    - format String
  # directive - the directive character ('x')
  # separator - used to separate the values in the NDC array
  #
  # Returns nil
  #
  # source://logging//lib/logging/layouts/pattern.rb#532
  def handle_ndc(format, directive, separator); end

  # Returns the value of attribute layout.
  #
  # source://logging//lib/logging/layouts/pattern.rb#338
  def layout; end

  # Returns the value of attribute name_map_count.
  #
  # source://logging//lib/logging/layouts/pattern.rb#343
  def name_map_count; end

  # Sets the attribute name_map_count
  #
  # @param value the value to set the attribute name_map_count to.
  #
  # source://logging//lib/logging/layouts/pattern.rb#343
  def name_map_count=(_arg0); end

  # Returns the value of attribute pattern.
  #
  # source://logging//lib/logging/layouts/pattern.rb#339
  def pattern; end

  # Sets the attribute pattern
  #
  # @param value the value to set the attribute pattern to.
  #
  # source://logging//lib/logging/layouts/pattern.rb#339
  def pattern=(_arg0); end

  # Returns the value of attribute sprintf_args.
  #
  # source://logging//lib/logging/layouts/pattern.rb#341
  def sprintf_args; end
end

# Human name aliases for directives - used for colorization of tokens
#
# source://logging//lib/logging/layouts/pattern.rb#322
Logging::Layouts::Pattern::FormatMethodBuilder::COLOR_ALIAS_TABLE = T.let(T.unsafe(nil), Hash)

# Matches the first directive encountered and the stuff around it.
#
# * $1 is the stuff before directive or "" if not applicable
# * $2 is the %#.# match within directive group
# * $3 is the directive letter
# * $4 is the precision specifier for the logger name
# * $5 is the stuff after the directive or "" if not applicable
#
# source://logging//lib/logging/layouts/pattern.rb#300
Logging::Layouts::Pattern::FormatMethodBuilder::DIRECTIVE_RGXP = T.let(T.unsafe(nil), Regexp)

# Arguments to sprintf keyed to directive letters
#
# source://logging//lib/logging/layouts/pattern.rb#303
Logging::Layouts::Pattern::FormatMethodBuilder::DIRECTIVE_TABLE = T.let(T.unsafe(nil), Hash)

# default date format
#
# source://logging//lib/logging/layouts/pattern.rb#155
Logging::Layouts::Pattern::ISO8601 = T.let(T.unsafe(nil), String)

# This class defines a logging event.
#
# source://logging//lib/logging/log_event.rb#5
class Logging::LogEvent
  # call-seq:
  #    LogEvent.new( logger, level, [data], caller_tracing )
  #
  # Creates a new log event with the given _logger_ name, numeric _level_,
  # array of _data_ from the user to be logged, and boolean _caller_tracing_ flag.
  # If the _caller_tracing_ flag is set to +true+ then Kernel::caller will be
  # invoked to get the execution trace of the logging method.
  #
  # @return [LogEvent] a new instance of LogEvent
  #
  # source://logging//lib/logging/log_event.rb#29
  def initialize(logger, level, data, caller_tracing); end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def data; end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def data=(_arg0); end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def file; end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def file=(_arg0); end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def level; end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def level=(_arg0); end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def line; end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def line=(_arg0); end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def logger; end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def logger=(_arg0); end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def method_name; end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def method_name=(_arg0); end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def time; end

  # :startdoc:
  #
  # source://logging//lib/logging/log_event.rb#19
  def time=(_arg0); end
end

# CALLER_INDEX = 2
#
# source://logging//lib/logging/log_event.rb#15
Logging::LogEvent::CALLER_INDEX = T.let(T.unsafe(nil), Integer)

# Regular expression used to parse out caller information
#
# * $1 == filename
# * $2 == line number
# * $3 == method name (might be nil)
#
# source://logging//lib/logging/log_event.rb#13
Logging::LogEvent::CALLER_RGXP = T.let(T.unsafe(nil), Regexp)

# The +Logger+ class is the primary interface to the +Logging+ framework.
# It provides the logging methods that will be called from user methods,
# and it generates logging events that are sent to the appenders (the
# appenders take care of sending the log events to the logging
# destinations -- files, sockets, etc).
#
# +Logger+ instances are obtained from the +Repository+ and should
# not be directly created by users.
#
# Example:
#
#    log = Logging.logger['my logger']
#    log.add_appenders( Logging.appenders.stdout )   # append to STDOUT
#    log.level = :info                               # log 'info' and above
#
#    log.info 'starting foo operation'
#    ...
#    log.info 'finishing foo operation'
#    ...
#    log.fatal 'unknown exception', exception
#
# source://logging//lib/logging/logger.rb#25
class Logging::Logger
  include ::Logging::RailsCompat

  # call-seq:
  #    Logger.new( name )
  #    Logger[name]
  #
  # Returns the logger identified by _name_.
  #
  # When _name_ is a +String+ or a +Symbol+ it will be used "as is" to
  # retrieve the logger. When _name_ is a +Class+ the class name will be
  # used to retrieve the logger. When _name_ is an object the name of the
  # object's class will be used to retrieve the logger.
  #
  # Example:
  #
  #   obj = MyClass.new
  #
  #   log1 = Logger.new(obj)
  #   log2 = Logger.new(MyClass)
  #   log3 = Logger['MyClass']
  #
  #   log1.object_id == log2.object_id         # => true
  #   log2.object_id == log3.object_id         # => true
  #
  # @return [Logger] a new instance of Logger
  #
  # source://logging//lib/logging/logger.rb#154
  def initialize(name); end

  # call-seq:
  #    log << "message"
  #
  # Log the given message without any formatting and without performing any
  # level checks. The message is logged to all appenders. The message is
  # passed up the logger tree if this logger's additivity is +true+.
  #
  # source://logging//lib/logging/logger.rb#185
  def <<(msg); end

  # call-seq:
  #    log <=> other
  #
  # Compares this logger by name to another logger. The normal return codes
  # for +String+ objects apply.
  #
  # source://logging//lib/logging/logger.rb#170
  def <=>(other); end

  # call-seq:
  #    _dump_configuration( io = STDOUT, indent = 0 )
  #
  # An internal method that is used to dump this logger's configuration to
  # the given _io_ stream. The configuration includes the logger's name,
  # level, additivity, and caller_tracing settings. The configured appenders
  # are also printed to the _io_ stream.
  #
  # source://logging//lib/logging/logger.rb#472
  def _dump_configuration(indent = T.unsafe(nil)); end

  # call-seq:
  #    _meta_eval( code )
  #
  # Evaluates the given string of _code_ if the singleton class of this
  # Logger object.
  #
  # source://logging//lib/logging/logger.rb#441
  def _meta_eval(code, file = T.unsafe(nil), line = T.unsafe(nil)); end

  # call-seq:
  #    _setup( name, opts = {} )
  #
  # Configures internal variables for the logger. This method can be used
  # to avoid storing the logger in the repository.
  #
  # source://logging//lib/logging/logger.rb#452
  def _setup(name, opts = T.unsafe(nil)); end

  # call-seq:
  #    add( severity, message = nil ) {block}
  #
  # Log a message if the given severity is high enough.  This is the generic
  # logging method.  Users will be more inclined to use #debug, #info, #warn,
  # #error, and #fatal.
  #
  # <b>Message format</b>: +message+ can be any object, but it has to be
  # converted to a String in order to log it. The Logging::format_as
  # method is used to determine how objects chould be converted to
  # strings. Generally, +inspect+ is used.
  #
  # A special case is an +Exception+ object, which will be printed in
  # detail, including message, class, and backtrace.
  #
  # If a _message_ is not given, then the return value from the block is
  # used as the message to log. This is useful when creating the actual
  # message is an expensive operation. This allows the logger to check the
  # severity against the configured level before actually constructing the
  # message.
  #
  # This method returns +true+ if the message was logged, and +false+ is
  # returned if the message was not logged.
  #
  # source://logging//lib/logging/logger.rb#215
  def add(lvl, data = T.unsafe(nil), progname = T.unsafe(nil)); end

  # call-seq:
  #    add_appenders( appenders )
  #
  # Add the given _appenders_ to the list of appenders, where _appenders_
  # can be either a single appender or an array of appenders.
  #
  # source://logging//lib/logging/logger.rb#349
  def add_appenders(*args); end

  # Returns the value of attribute additive.
  #
  # source://logging//lib/logging/logger.rb#130
  def additive; end

  # call-seq:
  #    additive = true
  #
  # Sets the additivity of the logger. Acceptable values are +true+,
  # 'true', +false+, 'false', or +nil+. In this case +nil+ does not
  # change the additivity
  #
  # source://logging//lib/logging/logger.rb#238
  def additive=(val); end

  # Returns the list of appenders.
  #
  # source://logging//lib/logging/logger.rb#328
  def appenders; end

  # call-seq:
  #    appenders = app
  #
  # Clears the current list of appenders and replaces them with _app_,
  # where _app_ can be either a single appender or an array of appenders.
  #
  # source://logging//lib/logging/logger.rb#338
  def appenders=(args); end

  # Returns the value of attribute caller_tracing.
  #
  # source://logging//lib/logging/logger.rb#130
  def caller_tracing; end

  # call-seq:
  #    caller_tracing = true
  #
  # Sets the caller tracing of the logger. Acceptable values are +true+,
  # 'true', +false+, 'false', or +nil+. In this case +nil+ does not change
  # the tracing.
  #
  # source://logging//lib/logging/logger.rb#253
  def caller_tracing=(val); end

  # call-seq:
  #    clear_appenders
  #
  # Remove all appenders from this logger.
  #
  # source://logging//lib/logging/logger.rb#385
  def clear_appenders; end

  # source://phobos/2.1.4/lib/phobos.rb#42
  def formatter=(*args); end

  # Returns `true` if the logger has its own level defined.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/logger.rb#322
  def has_own_level?; end

  # call-seq:
  #    level    => integer
  #
  # Returns an integer which is the defined log level for this logger.
  #
  # source://logging//lib/logging/logger.rb#267
  def level; end

  # call-seq:
  #    level = :all
  #
  # Set the level for this logger. The level can be either a +String+, a
  # +Symbol+, or an +Integer+. An +ArgumentError+ is raised if this is not
  # the case.
  #
  # There are two special levels -- "all" and "off". The former will
  # enable log messages from this logger. The latter will disable all log
  # messages from this logger.
  #
  # Setting the logger level to +nil+ will cause the parent's logger level
  # to be used.
  #
  # Example:
  #
  #    log.level = :debug
  #    log.level = "INFO"
  #    log.level = 4
  #    log.level = 'off'
  #    log.level = :all
  #
  # These produce an +ArgumentError+
  #
  #    log.level = Object
  #    log.level = -1
  #    log.level = 1_000_000_000_000
  #
  # source://logging//lib/logging/logger.rb#300
  def level=(level); end

  # Returns the value of attribute name.
  #
  # source://logging//lib/logging/logger.rb#130
  def name; end

  # Returns the value of attribute parent.
  #
  # source://logging//lib/logging/logger.rb#130
  def parent; end

  # source://phobos/2.1.4/lib/phobos.rb#48
  def pop_tags(*args); end

  # source://phobos/2.1.4/lib/phobos.rb#45
  def push_tags(*args); end

  # call-seq:
  #    remove_appenders( appenders )
  #
  # Remove the given _appenders_ from the list of appenders. The appenders
  # to remove can be identified either by name using a +String+ or by
  # passing the appender instance. _appenders_ can be a single appender or
  # an array of appenders.
  #
  # source://logging//lib/logging/logger.rb#366
  def remove_appenders(*args); end

  # call-seq:
  #    log << "message"
  #
  # Log the given message without any formatting and without performing any
  # level checks. The message is logged to all appenders. The message is
  # passed up the logger tree if this logger's additivity is +true+.
  #
  # source://logging//lib/logging/logger.rb#185
  def write(msg); end

  protected

  # call-seq:
  #    define_log_methods( force = false )
  #
  # Define the logging methods for this logger based on the configured log
  # level. If the level is nil, then we will ask our parent for it's level
  # and define log levels accordingly. The force flag will skip this
  # check.
  #
  # Recursively call this method on all our children loggers.
  #
  # source://logging//lib/logging/logger.rb#420
  def define_log_methods(force = T.unsafe(nil), code = T.unsafe(nil)); end

  # call-seq:
  #    log_event( event )
  #
  # Send the given _event_ to the appenders for logging, and pass the
  # _event_ up to the parent if additive mode is enabled. The log level has
  # already been checked before this method is called.
  #
  # source://logging//lib/logging/logger.rb#405
  def log_event(event); end

  # call-seq:
  #    parent = ParentLogger
  #
  # Set the parent logger for this logger. This method will be invoked by
  # the +Repository+ class when a parent or child is added to the
  # hierarchy.
  #
  # source://logging//lib/logging/logger.rb#396
  def parent=(parent); end

  class << self
    # Returns a logger instance for the given name.
    #
    # source://logging//lib/logging/logger.rb#43
    def [](name); end

    # This is where the actual logging methods are defined. Two methods
    # are created for each log level. The first is a query method used to
    # determine if that perticular logging level is enabled. The second is
    # the actual logging method that accepts a list of objects to be
    # logged or a block. If a block is given, then the object returned
    # from the block will be logged.
    #
    # Example
    #
    #    log = Logging::Logger['my logger']
    #    log.level = :warn
    #
    #    log.info?                               # => false
    #    log.warn?                               # => true
    #    log.warn 'this is your last warning'
    #    log.fatal 'I die!', exception
    #
    #    log.debug do
    #      # expensive method to construct log message
    #      msg
    #    end
    #
    # source://logging//lib/logging/logger.rb#85
    def define_log_methods(logger); end

    # `instantiate` becomes the "real" `new`
    def instantiate(*_arg0); end

    # This generator is used to define the log methods for the given `level`.
    # This code is evaluated in the context of a Logger instance.
    #
    # Returns log methods as a String
    #
    # source://logging//lib/logging/logger.rb#95
    def log_methods_for_level(level); end

    # Returns a global ReentrantMutex for use when creating Logger instances
    # and/or updating log levels.
    #
    # source://logging//lib/logging/logger.rb#126
    def mutex; end

    # Overrides the new method such that only one Logger will be created
    # for any given logger name.
    #
    # source://logging//lib/logging/logger.rb#38
    def new(*args); end

    # Returns the root logger.
    #
    # source://logging//lib/logging/logger.rb#28
    def root; end
  end
end

# source://logging//lib/logging.rb#258
Logging::MAX_LEVEL_LENGTH = T.let(T.unsafe(nil), Integer)

# A Mapped Diagnostic Context, or MDC in short, is an instrument used to
# distinguish interleaved log output from different sources. Log output is
# typically interleaved when a server handles multiple clients
# near-simultaneously.
#
# Interleaved log output can still be meaningful if each log entry from
# different contexts had a distinctive stamp. This is where MDCs come into
# play.
#
# The MDC provides a hash of contextual messages that are identified by
# unique keys. These unique keys are set by the application and appended
# to log messages to identify groups of log events. One use of the Mapped
# Diagnostic Context is to store HTTP request headers associated with a Rack
# request. These headers can be included with all log messages emitted while
# generating the HTTP response.
#
# When configured to do so, PatternLayout instances will automatically
# retrieve the mapped diagnostic context for the current thread with out any
# user intervention. This context information can be used to track user
# sessions in a Rails application, for example.
#
# Note that MDCs are managed on a per thread basis. MDC operations such as
# `[]`, `[]=`, and `clear` affect the MDC of the current thread only. MDCs
# of other threads remain unaffected.
#
# By default, when a new thread is created it will inherit the context of
# its parent thread. However, the `inherit` method may be used to inherit
# context for any other thread in the application.
#
# source://logging//lib/logging/diagnostic_context.rb#33
module Logging::MappedDiagnosticContext
  extend ::Logging::MappedDiagnosticContext

  # Public: Get the context value identified with the key parameter.
  #
  # key - The String identifier for the context.
  #
  # Returns the value associated with the key or nil if there is no value
  # present.
  #
  # source://logging//lib/logging/diagnostic_context.rb#62
  def [](key); end

  # Public: Put a context value as identified with the key parameter into
  # the current thread's context map.
  #
  # key   - The String identifier for the context.
  # value - The String value to store.
  #
  # Returns the value.
  #
  # source://logging//lib/logging/diagnostic_context.rb#50
  def []=(key, value); end

  # Public: Clear all mapped diagnostic information if any. This method is
  # useful in cases where the same thread can be potentially used over and
  # over in different unrelated contexts.
  #
  # Returns the MappedDiagnosticContext.
  #
  # source://logging//lib/logging/diagnostic_context.rb#126
  def clear; end

  # Remove the flattened context.
  #
  # source://logging//lib/logging/diagnostic_context.rb#196
  def clear_context; end

  # Returns the Hash acting as the storage for this MappedDiagnosticContext.
  # A new storage Hash is created for each Thread running in the
  # application.
  #
  # source://logging//lib/logging/diagnostic_context.rb#160
  def context; end

  # Public: Remove the context value identified with the key parameter.
  #
  # key - The String identifier for the context.
  #
  # Returns the value associated with the key or nil if there is no value
  # present.
  #
  # source://logging//lib/logging/diagnostic_context.rb#73
  def delete(key); end

  # Given an Array of Hash objects, flatten all the key/value pairs from the
  # Hash objects in the ary into a single Hash. The flattening occurs left
  # to right. So that the key/value in the very last Hash overrides any
  # other key from the previous Hash objcts.
  #
  # ary - An Array of Hash objects.
  #
  # Returns a Hash.
  #
  # source://logging//lib/logging/diagnostic_context.rb#229
  def flatten(ary); end

  # Public: Inherit the diagnostic context of another thread. In the vast
  # majority of cases the other thread will the parent that spawned the
  # current thread. The diagnostic context from the parent thread is cloned
  # before being inherited; the two diagnostic contexts can be changed
  # independently.
  #
  # Returns the MappedDiagnosticContext.
  #
  # source://logging//lib/logging/diagnostic_context.rb#140
  def inherit(obj); end

  # Returns the most current Hash from the stack of contexts.
  #
  # source://logging//lib/logging/diagnostic_context.rb#190
  def peek; end

  # Public: Remove the most recently pushed Hash from the stack of contexts.
  # If no contexts have been pushed then no action will be taken. The
  # default context cannot be popped off the stack; please use the `clear`
  # method if you want to remove all key/value pairs from the context.
  #
  # Returns nil or the Hash removed from the stack.
  #
  # source://logging//lib/logging/diagnostic_context.rb#112
  def pop; end

  # Public: Push a new Hash of key/value pairs onto the stack of contexts.
  #
  # hash - The Hash of values to push onto the context stack.
  #
  # Returns this context.
  # Raises an ArgumentError if hash is not a Hash.
  #
  # source://logging//lib/logging/diagnostic_context.rb#99
  def push(hash); end

  # Given a Hash convert all keys into Strings. The values are not altered
  # in any way. The converted keys and their values are stored in the target
  # Hash if provided. Otherwise a new Hash is created and returned.
  #
  # hash   - The Hash of values to push onto the context stack.
  # target - The target Hash to store the key value pairs.
  #
  # Returns a new Hash with all keys converted to Strings.
  # Raises an ArgumentError if hash is not a Hash.
  #
  # source://logging//lib/logging/diagnostic_context.rb#211
  def sanitize(hash, target = T.unsafe(nil)); end

  # Returns the stack of Hash objects that are storing the diagnostic
  # context information. This stack is guarnteed to always contain at least
  # one Hash.
  #
  # source://logging//lib/logging/diagnostic_context.rb#179
  def stack; end

  # Public: Add all the key/value pairs from the given hash to the current
  # mapped diagnostic context. The keys will be converted to strings.
  # Existing keys of the same name will be overwritten.
  #
  # hash - The Hash of values to add to the current context.
  #
  # Returns this context.
  #
  # source://logging//lib/logging/diagnostic_context.rb#86
  def update(hash); end
end

# The name used to retrieve the MDC from thread-local storage.
#
# source://logging//lib/logging/diagnostic_context.rb#37
Logging::MappedDiagnosticContext::NAME = T.let(T.unsafe(nil), Symbol)

# The name used to retrieve the MDC stack from thread-local storage.
#
# source://logging//lib/logging/diagnostic_context.rb#40
Logging::MappedDiagnosticContext::STACK_NAME = T.let(T.unsafe(nil), Symbol)

# A Nested Diagnostic Context, or NDC in short, is an instrument to
# distinguish interleaved log output from different sources. Log output is
# typically interleaved when a server handles multiple clients
# near-simultaneously.
#
# Interleaved log output can still be meaningful if each log entry from
# different contexts had a distinctive stamp. This is where NDCs come into
# play.
#
# The NDC is a stack of contextual messages that are pushed and popped by
# the client as different contexts are encountered in the application. When a
# new context is entered, the client will `push` a new message onto the NDC
# stack. This message appears in all log messages. When this context is
# exited, the client will call `pop` to remove the message.
#
# * Contexts can be nested
# * When entering a context, call `Logging.ndc.push`
# * When leaving a context, call `Logging.ndc.pop`
# * Configure the PatternLayout to log context information
#
# There is no penalty for forgetting to match each push operation with a
# corresponding pop, except the obvious mismatch between the real
# application context and the context set in the NDC.
#
# When configured to do so, PatternLayout instance will automatically
# retrieve the nested diagnostic context for the current thread with out any
# user intervention. This context information can be used to track user
# sessions in a Rails application, for example.
#
# Note that NDCs are managed on a per thread basis. NDC operations such as
# `push`, `pop`, and `clear` affect the NDC of the current thread only. NDCs
# of other threads remain unaffected.
#
# By default, when a new thread is created it will inherit the context of
# its parent thread. However, the `inherit` method may be used to inherit
# context for any other thread in the application.
#
# source://logging//lib/logging/diagnostic_context.rb#277
module Logging::NestedDiagnosticContext
  extend ::Logging::NestedDiagnosticContext

  # Public: Push new diagnostic context information for the current thread.
  # The contents of the message parameter is determined solely by the
  # client.
  #
  # message - The message String to add to the current context.
  #
  # Returns the current NestedDiagnosticContext.
  #
  # source://logging//lib/logging/diagnostic_context.rb#291
  def <<(message); end

  # Public: Clear all nested diagnostic information if any. This method is
  # useful in cases where the same thread can be potentially used over and
  # over in different unrelated contexts.
  #
  # Returns the NestedDiagnosticContext.
  #
  # source://logging//lib/logging/diagnostic_context.rb#332
  def clear; end

  # Returns the Array acting as the storage stack for this
  # NestedDiagnosticContext. A new storage Array is created for each Thread
  # running in the application.
  #
  # source://logging//lib/logging/diagnostic_context.rb#363
  def context; end

  # Public: Inherit the diagnostic context of another thread. In the vast
  # majority of cases the other thread will the parent that spawned the
  # current thread. The diagnostic context from the parent thread is cloned
  # before being inherited; the two diagnostic contexts can be changed
  # independently.
  #
  # Returns the NestedDiagnosticContext.
  #
  # source://logging//lib/logging/diagnostic_context.rb#345
  def inherit(obj); end

  # Public: Looks at the last diagnostic context at the top of this NDC
  # without removing it. The returned value is the last pushed message. If
  # no context is available then `nil` is returned.
  #
  # Returns the last pushed diagnostic message String or nil if no messages
  # exist.
  #
  # source://logging//lib/logging/diagnostic_context.rb#322
  def peek; end

  # Public: Clients should call this method before leaving a diagnostic
  # context. The returned value is the last pushed message. If no
  # context is available then `nil` is returned.
  #
  # Returns the last pushed diagnostic message String or nil if no messages
  # exist.
  #
  # source://logging//lib/logging/diagnostic_context.rb#311
  def pop; end

  # Public: Push new diagnostic context information for the current thread.
  # The contents of the message parameter is determined solely by the
  # client.
  #
  # message - The message String to add to the current context.
  #
  # Returns the current NestedDiagnosticContext.
  #
  # source://logging//lib/logging/diagnostic_context.rb#291
  def push(message); end
end

# The name used to retrieve the NDC from thread-local storage.
#
# source://logging//lib/logging/diagnostic_context.rb#281
Logging::NestedDiagnosticContext::NAME = T.let(T.unsafe(nil), Symbol)

# source://logging//lib/logging.rb#23
Logging::PATH = T.let(T.unsafe(nil), String)

# source://logging//lib/logging.rb#28
module Logging::Plugins; end

# Defines a Proxy that will log all method calls on the proxied object. This
# class uses +method_missing+ on a "blank slate" object to intercept all
# method calls. The method name being called and the arguments are all
# logged to the proxied object's logger instance. The log level and other
# settings for the proxied object are honored by the Proxy instance.
#
# If you want, you can also supply your own +method_missing+ code as a block
# to the constructor.
#
#   Proxy.new(object) do |name, *args, &block|
#     # code to be executed before the proxied method
#     result = @object.send(name, *args, &block)
#     # code to be executed after the proxied method
#     result   # <-- always return the result
#   end
#
# The proxied object is available as the "@object" variable. The logger is
# available as the "@logger" variable.
#
# source://logging//lib/logging/proxy.rb#23
class Logging::Proxy
  # Create a new proxy for the given _object_. If an optional _block_ is
  # given it will be called before the proxied method. This _block_ will
  # replace the +method_missing+ implementation
  #
  # @return [Proxy] a new instance of Proxy
  #
  # source://logging//lib/logging/proxy.rb#35
  def initialize(object, &block); end

  # All hail the magic of method missing. Here is where we are going to log
  # the method call and then forward to the proxied object. The return value
  # from the proxied object method call is passed back.
  #
  # source://logging//lib/logging/proxy.rb#52
  def method_missing(name, *args, &block); end
end

# :stopdoc:
#
# source://logging//lib/logging/proxy.rb#26
Logging::Proxy::KEEPERS = T.let(T.unsafe(nil), Regexp)

# Rails compatibility module.
#
# The ActiveSupport gem adds a few methods to the default Ruby logger, and
# some Rails extensions expect these methods to exist. Those methods are
# implemented in this module and included in the Logging::Logger class when
# the ActiveSupport gem is present.
#
# source://logging//lib/logging/rails_compat.rb#9
module Logging::RailsCompat
  # A no-op implementation of the `formatter` method.
  #
  # source://logging//lib/logging/rails_compat.rb#12
  def formatter; end

  # A no-op implementation of the +silence+ method. Setting of log levels
  # should be done during the Logging configuration. It is the author's
  # opinion that overriding the log level programmatically is a logical
  # error.
  #
  # Please see https://github.com/TwP/logging/issues/11 for a more detailed
  # discussion of the issue.
  #
  # @yield [_self]
  # @yieldparam _self [Logging::RailsCompat] the object that the method was called on
  #
  # source://logging//lib/logging/rails_compat.rb#21
  def silence(*args); end
end

# The Repository is a hash that stores references to all Loggers
# that have been created. It provides methods to determine parent/child
# relationships between Loggers and to retrieve Loggers from the hash.
#
# source://logging//lib/logging/repository.rb#10
class Logging::Repository
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # nodoc:
  #
  # This is a singleton class -- use the +instance+ method to obtain the
  # +Repository+ instance.
  #
  # @return [Repository] a new instance of Repository
  #
  # source://logging//lib/logging/repository.rb#20
  def initialize; end

  # call-seq:
  #    instance[name]
  #
  # Returns the +Logger+ named _name_.
  #
  # When _name_ is a +String+ or a +Symbol+ it will be used "as is" to
  # retrieve the logger. When _name_ is a +Class+ the class name will be
  # used to retrieve the logger. When _name_ is an object the name of the
  # object's class will be used to retrieve the logger.
  #
  # Example:
  #
  #   repo = Repository.instance
  #   obj = MyClass.new
  #
  #   log1 = repo[obj]
  #   log2 = repo[MyClass]
  #   log3 = repo['MyClass']
  #
  #   log1.object_id == log2.object_id         # => true
  #   log2.object_id == log3.object_id         # => true
  #
  # source://logging//lib/logging/repository.rb#56
  def [](key); end

  # call-seq:
  #    instance[name] = logger
  #
  # Stores the _logger_ under the given _name_.
  #
  # When _name_ is a +String+ or a +Symbol+ it will be used "as is" to
  # store the logger. When _name_ is a +Class+ the class name will be
  # used to store the logger. When _name_ is an object the name of the
  # object's class will be used to store the logger.
  #
  # source://logging//lib/logging/repository.rb#68
  def []=(key, val); end

  # call-seq:
  #    children( key )
  #
  # Returns an array of the children loggers for the logger identified by
  # _key_ where _key_ follows the same identification rules described in
  # +Repository#[]+. Children are returned regardless of the
  # existence of the logger referenced by _key_.
  #
  # source://logging//lib/logging/repository.rb#146
  def children(parent); end

  # call-seq:
  #    delete( name )
  #
  # Deletes the named logger from the repository. All direct children of the
  # logger will have their parent reassigned. So the parent of the logger
  # being deleted becomes the new parent of the children.
  #
  # When _name_ is a +String+ or a +Symbol+ it will be used "as is" to
  # remove the logger. When _name_ is a +Class+ the class name will be
  # used to remove the logger. When _name_ is an object the name of the
  # object's class will be used to remove the logger.
  #
  # Raises a RuntimeError if you try to delete the root logger.
  # Raises an KeyError if the named logger is not found.
  #
  # source://logging//lib/logging/repository.rb#110
  def delete(key); end

  # call-seq:
  #    fetch( name )
  #
  # Returns the +Logger+ named _name_. An +KeyError+ will be raised if
  # the logger does not exist.
  #
  # When _name_ is a +String+ or a +Symbol+ it will be used "as is" to
  # retrieve the logger. When _name_ is a +Class+ the class name will be
  # used to retrieve the logger. When _name_ is an object the name of the
  # object's class will be used to retrieve the logger.
  #
  # source://logging//lib/logging/repository.rb#81
  def fetch(key); end

  # call-seq:
  #    has_logger?( name )
  #
  # Returns +true+ if the given logger exists in the repository. Returns
  # +false+ if this is not the case.
  #
  # When _name_ is a +String+ or a +Symbol+ it will be used "as is" to
  # retrieve the logger. When _name_ is a +Class+ the class name will be
  # used to retrieve the logger. When _name_ is an object the name of the
  # object's class will be used to retrieve the logger.
  #
  # @return [Boolean]
  #
  # source://logging//lib/logging/repository.rb#94
  def has_logger?(key); end

  # call-seq:
  #    parent( key )
  #
  # Returns the parent logger for the logger identified by _key_ where
  # _key_ follows the same identification rules described in
  # <tt>Repository#[]</tt>. A parent is returned regardless of the
  # existence of the logger referenced by _key_.
  #
  # A note about parents -
  #
  # If you have a class A::B::C, then the parent of C is B, and the parent
  # of B is A. Parents are determined by namespace.
  #
  # source://logging//lib/logging/repository.rb#132
  def parent(key); end

  # Returns the name of the parent for the logger identified by the given
  # _key_. If the _key_ is for the root logger, then +nil+ is returned.
  #
  # source://logging//lib/logging/repository.rb#180
  def parent_name(key); end

  # call-seq:
  #    to_key( key )
  #
  # Takes the given _key_ and converts it into a form that can be used to
  # retrieve a logger from the +Repository+ hash.
  #
  # When _key_ is a +String+ or a +Symbol+ it will be returned "as is".
  # When _key_ is a +Class+ the class name will be returned. When _key_ is
  # an object the name of the object's class will be returned.
  #
  # source://logging//lib/logging/repository.rb#167
  def to_key(key); end

  class << self
    # :stopdoc:
    #
    # source://logging//lib/logging/repository.rb#193
    def reset; end

    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://logging//lib/logging/repository.rb#13
Logging::Repository::PATH_DELIMITER = T.let(T.unsafe(nil), String)

# The root logger exists to ensure that all loggers have a parent and a
# defined logging level. If a logger is additive, eventually its log
# events will propagate up to the root logger.
#
# source://logging//lib/logging/root_logger.rb#8
class Logging::RootLogger < ::Logging::Logger
  # call-seq:
  #    RootLogger.new
  #
  # Returns a new root logger instance. This method will be called only
  # once when the +Repository+ singleton instance is created.
  #
  # @return [RootLogger] a new instance of RootLogger
  #
  # source://logging//lib/logging/root_logger.rb#23
  def initialize; end

  # call-seq:
  #    log <=> other
  #
  # Compares this logger by name to another logger. The normal return codes
  # for +String+ objects apply.
  #
  # source://logging//lib/logging/root_logger.rb#40
  def <=>(other); end

  # Returns the value of attribute level.
  #
  # source://logging//lib/logging/root_logger.rb#15
  def level; end

  # call-seq:
  #    level = :all
  #
  # Set the level for the root logger. The functionality of this method is
  # the same as +Logger#level=+, but setting the level to +nil+ for the
  # root logger is not allowed. The level is silently set to :all.
  #
  # source://logging//lib/logging/root_logger.rb#54
  def level=(level); end
end

# source://logging//lib/logging/version.rb#2
Logging::VERSION = T.let(T.unsafe(nil), String)

# --------------------------------------------------------------------------
#
# source://logging//lib/logging/utils.rb#36
class Module
  # call-seq:
  #    logger_name    #=> string
  #
  # Returns a predictable logger name for the current module or class. If
  # used within an anonymous class, the first non-anonymous class name will
  # be used as the logger name. If used within a meta-class, the name of the
  # actual class will be used as the logger name. If used within an
  # anonymous module, the string 'anonymous' will be returned.
  #
  # source://logging//lib/logging/utils.rb#47
  def logger_name; end
end

# --------------------------------------------------------------------------
#
# source://logging//lib/logging/utils.rb#146
class ReentrantMutex < ::Thread::Mutex
  # @return [ReentrantMutex] a new instance of ReentrantMutex
  #
  # source://logging//lib/logging/utils.rb#148
  def initialize; end

  def original_synchronize; end

  # source://logging//lib/logging/utils.rb#155
  def synchronize; end
end

# --------------------------------------------------------------------------
#
# source://logging//lib/logging/utils.rb#6
class String
  include ::Comparable

  # call-seq:
  #    shrink( width, ellipses = '...' )    #=> string
  #
  # Shrink the size of the current string to the given _width_ by removing
  # characters from the middle of the string and replacing them with
  # _ellipses_. If the _width_ is greater than the length of the string, the
  # string is returned unchanged. If the _width_ is less than the length of
  # the _ellipses_, then the _ellipses_ are returned.
  #
  # @raise [ArgumentError]
  #
  # source://logging//lib/logging/utils.rb#17
  def shrink(width, ellipses = T.unsafe(nil)); end
end

# source://logging//lib/logging/diagnostic_context.rb#429
class Thread
  class << self
    # source://logging//lib/logging/diagnostic_context.rb#435
    def fork(*a, &b); end

    # source://logging//lib/logging/diagnostic_context.rb#435
    def new(*a, &b); end

    # source://logging//lib/logging/diagnostic_context.rb#435
    def start(*a, &b); end

    private

    # In order for the diagnostic contexts to behave properly we need to
    # inherit state from the parent thread. The only way I have found to do
    # this in Ruby is to override `new` and capture the contexts from the
    # parent Thread at the time the child Thread is created. The code below does
    # just this. If there is a more idiomatic way of accomplishing this in Ruby,
    # please let me know!
    #
    # Also, great care is taken in this code to ensure that a reference to the
    # parent thread does not exist in the binding associated with the block
    # being executed in the child thread. The same is true for the parent
    # thread's mdc and ndc. If any of those references end up in the binding,
    # then they cannot be garbage collected until the child thread exits.
    #
    # source://logging//lib/logging/diagnostic_context.rb#457
    def create_with_logging_context(m, *a, &b); end
  end
end
